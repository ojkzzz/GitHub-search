import {
  es_exports,
  init_es,
  init_redux,
  init_redux_toolkit_esm,
  redux_exports,
  redux_toolkit_esm_exports
} from "./chunk-O7CBDI2O.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-J43GMYXM.js";

// node_modules/immer/dist/immer.cjs.development.js
var require_immer_cjs_development = __commonJS({
  "node_modules/immer/dist/immer.cjs.development.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ref;
    var hasSymbol = typeof Symbol !== "undefined" && typeof Symbol("x") === "symbol";
    var hasMap = typeof Map !== "undefined";
    var hasSet = typeof Set !== "undefined";
    var hasProxies = typeof Proxy !== "undefined" && typeof Proxy.revocable !== "undefined" && typeof Reflect !== "undefined";
    var NOTHING = hasSymbol ? Symbol.for("immer-nothing") : (_ref = {}, _ref["immer-nothing"] = true, _ref);
    var DRAFTABLE = hasSymbol ? Symbol.for("immer-draftable") : "__$immer_draftable";
    var DRAFT_STATE = hasSymbol ? Symbol.for("immer-state") : "__$immer_state";
    var iteratorSymbol = typeof Symbol != "undefined" && Symbol.iterator || "@@iterator";
    var errors = {
      0: "Illegal state",
      1: "Immer drafts cannot have computed properties",
      2: "This object has been frozen and should not be mutated",
      3: function _(data) {
        return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
      },
      4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
      5: "Immer forbids circular references",
      6: "The first or second argument to `produce` must be a function",
      7: "The third argument to `produce` must be a function or undefined",
      8: "First argument to `createDraft` must be a plain object, an array, or an immerable object",
      9: "First argument to `finishDraft` must be a draft returned by `createDraft`",
      10: "The given draft is already finalized",
      11: "Object.defineProperty() cannot be used on an Immer draft",
      12: "Object.setPrototypeOf() cannot be used on an Immer draft",
      13: "Immer only supports deleting array indices",
      14: "Immer only supports setting array indices and the 'length' property",
      15: function _(path) {
        return "Cannot apply patch, path doesn't resolve: " + path;
      },
      16: 'Sets cannot have "replace" patches.',
      17: function _(op) {
        return "Unsupported patch operation: " + op;
      },
      18: function _(plugin) {
        return "The plugin for '" + plugin + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + plugin + "()` when initializing your application.";
      },
      20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",
      21: function _(thing) {
        return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + thing + "'";
      },
      22: function _(thing) {
        return "'current' expects a draft, got: " + thing;
      },
      23: function _(thing) {
        return "'original' expects a draft, got: " + thing;
      },
      24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
    };
    function die(error) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      {
        var e = errors[error];
        var msg = !e ? "unknown error nr: " + error : typeof e === "function" ? e.apply(null, args) : e;
        throw new Error("[Immer] " + msg);
      }
    }
    function isDraft(value) {
      return !!value && !!value[DRAFT_STATE];
    }
    function isDraftable(value) {
      var _value$constructor;
      if (!value)
        return false;
      return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);
    }
    var objectCtorString = Object.prototype.constructor.toString();
    function isPlainObject(value) {
      if (!value || typeof value !== "object")
        return false;
      var proto = Object.getPrototypeOf(value);
      if (proto === null) {
        return true;
      }
      var Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      if (Ctor === Object)
        return true;
      return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
    }
    function original(value) {
      if (!isDraft(value))
        die(23, value);
      return value[DRAFT_STATE].base_;
    }
    var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function(obj) {
      return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
    } : Object.getOwnPropertyNames;
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
      var res = {};
      ownKeys(target).forEach(function(key) {
        res[key] = Object.getOwnPropertyDescriptor(target, key);
      });
      return res;
    };
    function each(obj, iter, enumerableOnly) {
      if (enumerableOnly === void 0) {
        enumerableOnly = false;
      }
      if (getArchtype(obj) === 0) {
        (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function(key) {
          if (!enumerableOnly || typeof key !== "symbol")
            iter(key, obj[key], obj);
        });
      } else {
        obj.forEach(function(entry, index) {
          return iter(index, entry, obj);
        });
      }
    }
    function getArchtype(thing) {
      var state = thing[DRAFT_STATE];
      return state ? state.type_ > 3 ? state.type_ - 4 : state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
    }
    function has(thing, prop) {
      return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
    }
    function get(thing, prop) {
      return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];
    }
    function set(thing, propOrOldValue, value) {
      var t = getArchtype(thing);
      if (t === 2)
        thing.set(propOrOldValue, value);
      else if (t === 3) {
        thing.delete(propOrOldValue);
        thing.add(value);
      } else
        thing[propOrOldValue] = value;
    }
    function is(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function isMap(target) {
      return hasMap && target instanceof Map;
    }
    function isSet(target) {
      return hasSet && target instanceof Set;
    }
    function latest(state) {
      return state.copy_ || state.base_;
    }
    function shallowCopy(base) {
      if (Array.isArray(base))
        return Array.prototype.slice.call(base);
      var descriptors = getOwnPropertyDescriptors(base);
      delete descriptors[DRAFT_STATE];
      var keys = ownKeys(descriptors);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var desc = descriptors[key];
        if (desc.writable === false) {
          desc.writable = true;
          desc.configurable = true;
        }
        if (desc.get || desc.set)
          descriptors[key] = {
            configurable: true,
            writable: true,
            enumerable: desc.enumerable,
            value: base[key]
          };
      }
      return Object.create(Object.getPrototypeOf(base), descriptors);
    }
    function freeze(obj, deep) {
      if (deep === void 0) {
        deep = false;
      }
      if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
        return obj;
      if (getArchtype(obj) > 1) {
        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
      }
      Object.freeze(obj);
      if (deep)
        each(obj, function(key, value) {
          return freeze(value, true);
        }, true);
      return obj;
    }
    function dontMutateFrozenCollections() {
      die(2);
    }
    function isFrozen(obj) {
      if (obj == null || typeof obj !== "object")
        return true;
      return Object.isFrozen(obj);
    }
    var plugins = {};
    function getPlugin(pluginKey) {
      var plugin = plugins[pluginKey];
      if (!plugin) {
        die(18, pluginKey);
      }
      return plugin;
    }
    function loadPlugin(pluginKey, implementation) {
      if (!plugins[pluginKey])
        plugins[pluginKey] = implementation;
    }
    var currentScope;
    function getCurrentScope() {
      if (!currentScope)
        die(0);
      return currentScope;
    }
    function createScope(parent_, immer_) {
      return {
        drafts_: [],
        parent_,
        immer_,
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
      };
    }
    function usePatchesInScope(scope, patchListener) {
      if (patchListener) {
        getPlugin("Patches");
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
      }
    }
    function revokeScope(scope) {
      leaveScope(scope);
      scope.drafts_.forEach(revokeDraft);
      scope.drafts_ = null;
    }
    function leaveScope(scope) {
      if (scope === currentScope) {
        currentScope = scope.parent_;
      }
    }
    function enterScope(immer2) {
      return currentScope = createScope(currentScope, immer2);
    }
    function revokeDraft(draft) {
      var state = draft[DRAFT_STATE];
      if (state.type_ === 0 || state.type_ === 1)
        state.revoke_();
      else
        state.revoked_ = true;
    }
    function processResult(result, scope) {
      scope.unfinalizedDrafts_ = scope.drafts_.length;
      var baseDraft = scope.drafts_[0];
      var isReplaced = result !== void 0 && result !== baseDraft;
      if (!scope.immer_.useProxies_)
        getPlugin("ES5").willFinalizeES5_(scope, result, isReplaced);
      if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
          revokeScope(scope);
          die(4);
        }
        if (isDraftable(result)) {
          result = finalize(scope, result);
          if (!scope.parent_)
            maybeFreeze(scope, result);
        }
        if (scope.patches_) {
          getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
        }
      } else {
        result = finalize(scope, baseDraft, []);
      }
      revokeScope(scope);
      if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
      }
      return result !== NOTHING ? result : void 0;
    }
    function finalize(rootScope, value, path) {
      if (isFrozen(value))
        return value;
      var state = value[DRAFT_STATE];
      if (!state) {
        each(
          value,
          function(key, childValue) {
            return finalizeProperty(rootScope, state, value, key, childValue, path);
          },
          true
        );
        return value;
      }
      if (state.scope_ !== rootScope)
        return value;
      if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
      }
      if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        var result = state.type_ === 4 || state.type_ === 5 ? state.copy_ = shallowCopy(state.draft_) : state.copy_;
        each(state.type_ === 3 ? new Set(result) : result, function(key, childValue) {
          return finalizeProperty(rootScope, state, result, key, childValue, path);
        });
        maybeFreeze(rootScope, result, false);
        if (path && rootScope.patches_) {
          getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
        }
      }
      return state.copy_;
    }
    function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath) {
      if (childValue === targetObject)
        die(5);
      if (isDraft(childValue)) {
        var path = rootPath && parentState && parentState.type_ !== 3 && !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        var res = finalize(rootScope, childValue, path);
        set(targetObject, prop, res);
        if (isDraft(res)) {
          rootScope.canAutoFreeze_ = false;
        } else
          return;
      }
      if (isDraftable(childValue) && !isFrozen(childValue)) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
          return;
        }
        finalize(rootScope, childValue);
        if (!parentState || !parentState.scope_.parent_)
          maybeFreeze(rootScope, childValue);
      }
    }
    function maybeFreeze(scope, value, deep) {
      if (deep === void 0) {
        deep = false;
      }
      if (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze(value, deep);
      }
    }
    function createProxyProxy(base, parent) {
      var isArray = Array.isArray(base);
      var state = {
        type_: isArray ? 1 : 0,
        scope_: parent ? parent.scope_ : getCurrentScope(),
        modified_: false,
        finalized_: false,
        assigned_: {},
        parent_: parent,
        base_: base,
        draft_: null,
        copy_: null,
        revoke_: null,
        isManual_: false
      };
      var target = state;
      var traps = objectTraps;
      if (isArray) {
        target = [state];
        traps = arrayTraps;
      }
      var _Proxy$revocable = Proxy.revocable(target, traps), revoke = _Proxy$revocable.revoke, proxy = _Proxy$revocable.proxy;
      state.draft_ = proxy;
      state.revoke_ = revoke;
      return proxy;
    }
    var objectTraps = {
      get: function get2(state, prop) {
        if (prop === DRAFT_STATE)
          return state;
        var source = latest(state);
        if (!has(source, prop)) {
          return readPropFromProto(state, source, prop);
        }
        var value = source[prop];
        if (state.finalized_ || !isDraftable(value)) {
          return value;
        }
        if (value === peek(state.base_, prop)) {
          prepareCopy(state);
          return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);
        }
        return value;
      },
      has: function has2(state, prop) {
        return prop in latest(state);
      },
      ownKeys: function ownKeys2(state) {
        return Reflect.ownKeys(latest(state));
      },
      set: function set2(state, prop, value) {
        var desc = getDescriptorFromProto(latest(state), prop);
        if (desc === null || desc === void 0 ? void 0 : desc.set) {
          desc.set.call(state.draft_, value);
          return true;
        }
        if (!state.modified_) {
          var current2 = peek(latest(state), prop);
          var currentState = current2 === null || current2 === void 0 ? void 0 : current2[DRAFT_STATE];
          if (currentState && currentState.base_ === value) {
            state.copy_[prop] = value;
            state.assigned_[prop] = false;
            return true;
          }
          if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
            return true;
          prepareCopy(state);
          markChanged(state);
        }
        if (state.copy_[prop] === value && typeof value !== "number" && (value !== void 0 || prop in state.copy_))
          return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
      },
      deleteProperty: function deleteProperty(state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
          state.assigned_[prop] = false;
          prepareCopy(state);
          markChanged(state);
        } else {
          delete state.assigned_[prop];
        }
        if (state.copy_)
          delete state.copy_[prop];
        return true;
      },
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {
        var owner = latest(state);
        var desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc)
          return desc;
        return {
          writable: true,
          configurable: state.type_ !== 1 || prop !== "length",
          enumerable: desc.enumerable,
          value: owner[prop]
        };
      },
      defineProperty: function defineProperty() {
        die(11);
      },
      getPrototypeOf: function getPrototypeOf(state) {
        return Object.getPrototypeOf(state.base_);
      },
      setPrototypeOf: function setPrototypeOf() {
        die(12);
      }
    };
    var arrayTraps = {};
    each(objectTraps, function(key, fn) {
      arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
      };
    });
    arrayTraps.deleteProperty = function(state, prop) {
      if (isNaN(parseInt(prop)))
        die(13);
      return arrayTraps.set.call(this, state, prop, void 0);
    };
    arrayTraps.set = function(state, prop, value) {
      if (prop !== "length" && isNaN(parseInt(prop)))
        die(14);
      return objectTraps.set.call(this, state[0], prop, value, state[0]);
    };
    function peek(draft, prop) {
      var state = draft[DRAFT_STATE];
      var source = state ? latest(state) : draft;
      return source[prop];
    }
    function readPropFromProto(state, source, prop) {
      var _desc$get;
      var desc = getDescriptorFromProto(source, prop);
      return desc ? "value" in desc ? desc.value : (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : void 0;
    }
    function getDescriptorFromProto(source, prop) {
      if (!(prop in source))
        return void 0;
      var proto = Object.getPrototypeOf(source);
      while (proto) {
        var desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc)
          return desc;
        proto = Object.getPrototypeOf(proto);
      }
      return void 0;
    }
    function markChanged(state) {
      if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
          markChanged(state.parent_);
        }
      }
    }
    function prepareCopy(state) {
      if (!state.copy_) {
        state.copy_ = shallowCopy(state.base_);
      }
    }
    var Immer = function() {
      function Immer2(config) {
        var _this = this;
        this.useProxies_ = hasProxies;
        this.autoFreeze_ = true;
        this.produce = function(base, recipe, patchListener) {
          if (typeof base === "function" && typeof recipe !== "function") {
            var defaultBase = recipe;
            recipe = base;
            var self = _this;
            return function curriedProduce(base2) {
              var _this2 = this;
              if (base2 === void 0) {
                base2 = defaultBase;
              }
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              return self.produce(base2, function(draft) {
                var _recipe;
                return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));
              });
            };
          }
          if (typeof recipe !== "function")
            die(6);
          if (patchListener !== void 0 && typeof patchListener !== "function")
            die(7);
          var result;
          if (isDraftable(base)) {
            var scope = enterScope(_this);
            var proxy = createProxy(_this, base, void 0);
            var hasError = true;
            try {
              result = recipe(proxy);
              hasError = false;
            } finally {
              if (hasError)
                revokeScope(scope);
              else
                leaveScope(scope);
            }
            if (typeof Promise !== "undefined" && result instanceof Promise) {
              return result.then(function(result2) {
                usePatchesInScope(scope, patchListener);
                return processResult(result2, scope);
              }, function(error) {
                revokeScope(scope);
                throw error;
              });
            }
            usePatchesInScope(scope, patchListener);
            return processResult(result, scope);
          } else if (!base || typeof base !== "object") {
            result = recipe(base);
            if (result === void 0)
              result = base;
            if (result === NOTHING)
              result = void 0;
            if (_this.autoFreeze_)
              freeze(result, true);
            if (patchListener) {
              var p = [];
              var ip = [];
              getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
              patchListener(p, ip);
            }
            return result;
          } else
            die(21, base);
        };
        this.produceWithPatches = function(base, recipe) {
          if (typeof base === "function") {
            return function(state) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              return _this.produceWithPatches(state, function(draft) {
                return base.apply(void 0, [draft].concat(args));
              });
            };
          }
          var patches, inversePatches;
          var result = _this.produce(base, recipe, function(p, ip) {
            patches = p;
            inversePatches = ip;
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then(function(nextState) {
              return [nextState, patches, inversePatches];
            });
          }
          return [result, patches, inversePatches];
        };
        if (typeof (config === null || config === void 0 ? void 0 : config.useProxies) === "boolean")
          this.setUseProxies(config.useProxies);
        if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === "boolean")
          this.setAutoFreeze(config.autoFreeze);
      }
      var _proto = Immer2.prototype;
      _proto.createDraft = function createDraft2(base) {
        if (!isDraftable(base))
          die(8);
        if (isDraft(base))
          base = current(base);
        var scope = enterScope(this);
        var proxy = createProxy(this, base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope);
        return proxy;
      };
      _proto.finishDraft = function finishDraft2(draft, patchListener) {
        var state = draft && draft[DRAFT_STATE];
        {
          if (!state || !state.isManual_)
            die(9);
          if (state.finalized_)
            die(10);
        }
        var scope = state.scope_;
        usePatchesInScope(scope, patchListener);
        return processResult(void 0, scope);
      };
      _proto.setAutoFreeze = function setAutoFreeze2(value) {
        this.autoFreeze_ = value;
      };
      _proto.setUseProxies = function setUseProxies2(value) {
        if (value && !hasProxies) {
          die(20);
        }
        this.useProxies_ = value;
      };
      _proto.applyPatches = function applyPatches2(base, patches) {
        var i;
        for (i = patches.length - 1; i >= 0; i--) {
          var patch = patches[i];
          if (patch.path.length === 0 && patch.op === "replace") {
            base = patch.value;
            break;
          }
        }
        if (i > -1) {
          patches = patches.slice(i + 1);
        }
        var applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base)) {
          return applyPatchesImpl(base, patches);
        }
        return this.produce(base, function(draft) {
          return applyPatchesImpl(draft, patches);
        });
      };
      return Immer2;
    }();
    function createProxy(immer2, value, parent) {
      var draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : immer2.useProxies_ ? createProxyProxy(value, parent) : getPlugin("ES5").createES5Proxy_(value, parent);
      var scope = parent ? parent.scope_ : getCurrentScope();
      scope.drafts_.push(draft);
      return draft;
    }
    function current(value) {
      if (!isDraft(value))
        die(22, value);
      return currentImpl(value);
    }
    function currentImpl(value) {
      if (!isDraftable(value))
        return value;
      var state = value[DRAFT_STATE];
      var copy;
      var archType = getArchtype(value);
      if (state) {
        if (!state.modified_ && (state.type_ < 4 || !getPlugin("ES5").hasChanges_(state)))
          return state.base_;
        state.finalized_ = true;
        copy = copyHelper(value, archType);
        state.finalized_ = false;
      } else {
        copy = copyHelper(value, archType);
      }
      each(copy, function(key, childValue) {
        if (state && get(state.base_, key) === childValue)
          return;
        set(copy, key, currentImpl(childValue));
      });
      return archType === 3 ? new Set(copy) : copy;
    }
    function copyHelper(value, archType) {
      switch (archType) {
        case 2:
          return new Map(value);
        case 3:
          return Array.from(value);
      }
      return shallowCopy(value);
    }
    function enableES5() {
      function willFinalizeES5_(scope, result, isReplaced) {
        if (!isReplaced) {
          if (scope.patches_) {
            markChangesRecursively(scope.drafts_[0]);
          }
          markChangesSweep(scope.drafts_);
        } else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {
          markChangesSweep(scope.drafts_);
        }
      }
      function createES5Draft(isArray, base) {
        if (isArray) {
          var draft = new Array(base.length);
          for (var i = 0; i < base.length; i++) {
            Object.defineProperty(draft, "" + i, proxyProperty(i, true));
          }
          return draft;
        } else {
          var _descriptors = getOwnPropertyDescriptors(base);
          delete _descriptors[DRAFT_STATE];
          var keys = ownKeys(_descriptors);
          for (var _i = 0; _i < keys.length; _i++) {
            var key = keys[_i];
            _descriptors[key] = proxyProperty(key, isArray || !!_descriptors[key].enumerable);
          }
          return Object.create(Object.getPrototypeOf(base), _descriptors);
        }
      }
      function createES5Proxy_(base, parent) {
        var isArray = Array.isArray(base);
        var draft = createES5Draft(isArray, base);
        var state = {
          type_: isArray ? 5 : 4,
          scope_: parent ? parent.scope_ : getCurrentScope(),
          modified_: false,
          finalized_: false,
          assigned_: {},
          parent_: parent,
          base_: base,
          draft_: draft,
          copy_: null,
          revoked_: false,
          isManual_: false
        };
        Object.defineProperty(draft, DRAFT_STATE, {
          value: state,
          writable: true
        });
        return draft;
      }
      var descriptors = {};
      function proxyProperty(prop, enumerable) {
        var desc = descriptors[prop];
        if (desc) {
          desc.enumerable = enumerable;
        } else {
          descriptors[prop] = desc = {
            configurable: true,
            enumerable,
            get: function get2() {
              var state = this[DRAFT_STATE];
              assertUnrevoked(state);
              return objectTraps.get(state, prop);
            },
            set: function set2(value) {
              var state = this[DRAFT_STATE];
              assertUnrevoked(state);
              objectTraps.set(state, prop, value);
            }
          };
        }
        return desc;
      }
      function markChangesSweep(drafts) {
        for (var i = drafts.length - 1; i >= 0; i--) {
          var state = drafts[i][DRAFT_STATE];
          if (!state.modified_) {
            switch (state.type_) {
              case 5:
                if (hasArrayChanges(state))
                  markChanged(state);
                break;
              case 4:
                if (hasObjectChanges(state))
                  markChanged(state);
                break;
            }
          }
        }
      }
      function markChangesRecursively(object) {
        if (!object || typeof object !== "object")
          return;
        var state = object[DRAFT_STATE];
        if (!state)
          return;
        var base_ = state.base_, draft_ = state.draft_, assigned_ = state.assigned_, type_ = state.type_;
        if (type_ === 4) {
          each(draft_, function(key) {
            if (key === DRAFT_STATE)
              return;
            if (base_[key] === void 0 && !has(base_, key)) {
              assigned_[key] = true;
              markChanged(state);
            } else if (!assigned_[key]) {
              markChangesRecursively(draft_[key]);
            }
          });
          each(base_, function(key) {
            if (draft_[key] === void 0 && !has(draft_, key)) {
              assigned_[key] = false;
              markChanged(state);
            }
          });
        } else if (type_ === 5) {
          if (hasArrayChanges(state)) {
            markChanged(state);
            assigned_.length = true;
          }
          if (draft_.length < base_.length) {
            for (var i = draft_.length; i < base_.length; i++) {
              assigned_[i] = false;
            }
          } else {
            for (var _i2 = base_.length; _i2 < draft_.length; _i2++) {
              assigned_[_i2] = true;
            }
          }
          var min = Math.min(draft_.length, base_.length);
          for (var _i3 = 0; _i3 < min; _i3++) {
            if (!draft_.hasOwnProperty(_i3)) {
              assigned_[_i3] = true;
            }
            if (assigned_[_i3] === void 0)
              markChangesRecursively(draft_[_i3]);
          }
        }
      }
      function hasObjectChanges(state) {
        var base_ = state.base_, draft_ = state.draft_;
        var keys = ownKeys(draft_);
        for (var i = keys.length - 1; i >= 0; i--) {
          var key = keys[i];
          if (key === DRAFT_STATE)
            continue;
          var baseValue = base_[key];
          if (baseValue === void 0 && !has(base_, key)) {
            return true;
          } else {
            var value = draft_[key];
            var _state = value && value[DRAFT_STATE];
            if (_state ? _state.base_ !== baseValue : !is(value, baseValue)) {
              return true;
            }
          }
        }
        var baseIsDraft = !!base_[DRAFT_STATE];
        return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1);
      }
      function hasArrayChanges(state) {
        var draft_ = state.draft_;
        if (draft_.length !== state.base_.length)
          return true;
        var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1);
        if (descriptor && !descriptor.get)
          return true;
        for (var i = 0; i < draft_.length; i++) {
          if (!draft_.hasOwnProperty(i))
            return true;
        }
        return false;
      }
      function hasChanges_(state) {
        return state.type_ === 4 ? hasObjectChanges(state) : hasArrayChanges(state);
      }
      function assertUnrevoked(state) {
        if (state.revoked_)
          die(3, JSON.stringify(latest(state)));
      }
      loadPlugin("ES5", {
        createES5Proxy_,
        willFinalizeES5_,
        hasChanges_
      });
    }
    function enablePatches() {
      var REPLACE = "replace";
      var ADD = "add";
      var REMOVE = "remove";
      function generatePatches_(state, basePath, patches, inversePatches) {
        switch (state.type_) {
          case 0:
          case 4:
          case 2:
            return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
          case 5:
          case 1:
            return generateArrayPatches(state, basePath, patches, inversePatches);
          case 3:
            return generateSetPatches(state, basePath, patches, inversePatches);
        }
      }
      function generateArrayPatches(state, basePath, patches, inversePatches) {
        var base_ = state.base_, assigned_ = state.assigned_;
        var copy_ = state.copy_;
        if (copy_.length < base_.length) {
          var _ref2 = [copy_, base_];
          base_ = _ref2[0];
          copy_ = _ref2[1];
          var _ref22 = [inversePatches, patches];
          patches = _ref22[0];
          inversePatches = _ref22[1];
        }
        for (var i = 0; i < base_.length; i++) {
          if (assigned_[i] && copy_[i] !== base_[i]) {
            var path = basePath.concat([i]);
            patches.push({
              op: REPLACE,
              path,
              value: clonePatchValueIfNeeded(copy_[i])
            });
            inversePatches.push({
              op: REPLACE,
              path,
              value: clonePatchValueIfNeeded(base_[i])
            });
          }
        }
        for (var _i = base_.length; _i < copy_.length; _i++) {
          var _path = basePath.concat([_i]);
          patches.push({
            op: ADD,
            path: _path,
            value: clonePatchValueIfNeeded(copy_[_i])
          });
        }
        if (base_.length < copy_.length) {
          inversePatches.push({
            op: REPLACE,
            path: basePath.concat(["length"]),
            value: base_.length
          });
        }
      }
      function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
        var base_ = state.base_, copy_ = state.copy_;
        each(state.assigned_, function(key, assignedValue) {
          var origValue = get(base_, key);
          var value = get(copy_, key);
          var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
          if (origValue === value && op === REPLACE)
            return;
          var path = basePath.concat(key);
          patches.push(op === REMOVE ? {
            op,
            path
          } : {
            op,
            path,
            value
          });
          inversePatches.push(op === ADD ? {
            op: REMOVE,
            path
          } : op === REMOVE ? {
            op: ADD,
            path,
            value: clonePatchValueIfNeeded(origValue)
          } : {
            op: REPLACE,
            path,
            value: clonePatchValueIfNeeded(origValue)
          });
        });
      }
      function generateSetPatches(state, basePath, patches, inversePatches) {
        var base_ = state.base_, copy_ = state.copy_;
        var i = 0;
        base_.forEach(function(value) {
          if (!copy_.has(value)) {
            var path = basePath.concat([i]);
            patches.push({
              op: REMOVE,
              path,
              value
            });
            inversePatches.unshift({
              op: ADD,
              path,
              value
            });
          }
          i++;
        });
        i = 0;
        copy_.forEach(function(value) {
          if (!base_.has(value)) {
            var path = basePath.concat([i]);
            patches.push({
              op: ADD,
              path,
              value
            });
            inversePatches.unshift({
              op: REMOVE,
              path,
              value
            });
          }
          i++;
        });
      }
      function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
        patches.push({
          op: REPLACE,
          path: [],
          value: replacement === NOTHING ? void 0 : replacement
        });
        inversePatches.push({
          op: REPLACE,
          path: [],
          value: baseValue
        });
      }
      function applyPatches_(draft, patches) {
        patches.forEach(function(patch) {
          var path = patch.path, op = patch.op;
          var base = draft;
          for (var i = 0; i < path.length - 1; i++) {
            var parentType = getArchtype(base);
            var p = "" + path[i];
            if ((parentType === 0 || parentType === 1) && (p === "__proto__" || p === "constructor"))
              die(24);
            if (typeof base === "function" && p === "prototype")
              die(24);
            base = get(base, p);
            if (typeof base !== "object")
              die(15, path.join("/"));
          }
          var type = getArchtype(base);
          var value = deepClonePatchValue(patch.value);
          var key = path[path.length - 1];
          switch (op) {
            case REPLACE:
              switch (type) {
                case 2:
                  return base.set(key, value);
                case 3:
                  die(16);
                default:
                  return base[key] = value;
              }
            case ADD:
              switch (type) {
                case 1:
                  return key === "-" ? base.push(value) : base.splice(key, 0, value);
                case 2:
                  return base.set(key, value);
                case 3:
                  return base.add(value);
                default:
                  return base[key] = value;
              }
            case REMOVE:
              switch (type) {
                case 1:
                  return base.splice(key, 1);
                case 2:
                  return base.delete(key);
                case 3:
                  return base.delete(patch.value);
                default:
                  return delete base[key];
              }
            default:
              die(17, op);
          }
        });
        return draft;
      }
      function deepClonePatchValue(obj) {
        if (!isDraftable(obj))
          return obj;
        if (Array.isArray(obj))
          return obj.map(deepClonePatchValue);
        if (isMap(obj))
          return new Map(Array.from(obj.entries()).map(function(_ref3) {
            var k = _ref3[0], v = _ref3[1];
            return [k, deepClonePatchValue(v)];
          }));
        if (isSet(obj))
          return new Set(Array.from(obj).map(deepClonePatchValue));
        var cloned = Object.create(Object.getPrototypeOf(obj));
        for (var key in obj) {
          cloned[key] = deepClonePatchValue(obj[key]);
        }
        if (has(obj, DRAFTABLE))
          cloned[DRAFTABLE] = obj[DRAFTABLE];
        return cloned;
      }
      function clonePatchValueIfNeeded(obj) {
        if (isDraft(obj)) {
          return deepClonePatchValue(obj);
        } else
          return obj;
      }
      loadPlugin("Patches", {
        applyPatches_,
        generatePatches_,
        generateReplacementPatches_
      });
    }
    function enableMapSet() {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) {
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
          }
        };
        return _extendStatics(d, b);
      };
      function __extends(d, b) {
        _extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = (__.prototype = b.prototype, new __());
      }
      var DraftMap = function(_super) {
        __extends(DraftMap2, _super);
        function DraftMap2(target, parent) {
          this[DRAFT_STATE] = {
            type_: 2,
            parent_: parent,
            scope_: parent ? parent.scope_ : getCurrentScope(),
            modified_: false,
            finalized_: false,
            copy_: void 0,
            assigned_: void 0,
            base_: target,
            draft_: this,
            isManual_: false,
            revoked_: false
          };
          return this;
        }
        var p = DraftMap2.prototype;
        Object.defineProperty(p, "size", {
          get: function get2() {
            return latest(this[DRAFT_STATE]).size;
          }
        });
        p.has = function(key) {
          return latest(this[DRAFT_STATE]).has(key);
        };
        p.set = function(key, value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!latest(state).has(key) || latest(state).get(key) !== value) {
            prepareMapCopy(state);
            markChanged(state);
            state.assigned_.set(key, true);
            state.copy_.set(key, value);
            state.assigned_.set(key, true);
          }
          return this;
        };
        p.delete = function(key) {
          if (!this.has(key)) {
            return false;
          }
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareMapCopy(state);
          markChanged(state);
          if (state.base_.has(key)) {
            state.assigned_.set(key, false);
          } else {
            state.assigned_.delete(key);
          }
          state.copy_.delete(key);
          return true;
        };
        p.clear = function() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (latest(state).size) {
            prepareMapCopy(state);
            markChanged(state);
            state.assigned_ = /* @__PURE__ */ new Map();
            each(state.base_, function(key) {
              state.assigned_.set(key, false);
            });
            state.copy_.clear();
          }
        };
        p.forEach = function(cb, thisArg) {
          var _this = this;
          var state = this[DRAFT_STATE];
          latest(state).forEach(function(_value, key, _map) {
            cb.call(thisArg, _this.get(key), key, _this);
          });
        };
        p.get = function(key) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          var value = latest(state).get(key);
          if (state.finalized_ || !isDraftable(value)) {
            return value;
          }
          if (value !== state.base_.get(key)) {
            return value;
          }
          var draft = createProxy(state.scope_.immer_, value, state);
          prepareMapCopy(state);
          state.copy_.set(key, draft);
          return draft;
        };
        p.keys = function() {
          return latest(this[DRAFT_STATE]).keys();
        };
        p.values = function() {
          var _this2 = this, _ref2;
          var iterator = this.keys();
          return _ref2 = {}, _ref2[iteratorSymbol] = function() {
            return _this2.values();
          }, _ref2.next = function next() {
            var r = iterator.next();
            if (r.done)
              return r;
            var value = _this2.get(r.value);
            return {
              done: false,
              value
            };
          }, _ref2;
        };
        p.entries = function() {
          var _this3 = this, _ref2;
          var iterator = this.keys();
          return _ref2 = {}, _ref2[iteratorSymbol] = function() {
            return _this3.entries();
          }, _ref2.next = function next() {
            var r = iterator.next();
            if (r.done)
              return r;
            var value = _this3.get(r.value);
            return {
              done: false,
              value: [r.value, value]
            };
          }, _ref2;
        };
        p[iteratorSymbol] = function() {
          return this.entries();
        };
        return DraftMap2;
      }(Map);
      function proxyMap_(target, parent) {
        return new DraftMap(target, parent);
      }
      function prepareMapCopy(state) {
        if (!state.copy_) {
          state.assigned_ = /* @__PURE__ */ new Map();
          state.copy_ = new Map(state.base_);
        }
      }
      var DraftSet = function(_super) {
        __extends(DraftSet2, _super);
        function DraftSet2(target, parent) {
          this[DRAFT_STATE] = {
            type_: 3,
            parent_: parent,
            scope_: parent ? parent.scope_ : getCurrentScope(),
            modified_: false,
            finalized_: false,
            copy_: void 0,
            base_: target,
            draft_: this,
            drafts_: /* @__PURE__ */ new Map(),
            revoked_: false,
            isManual_: false
          };
          return this;
        }
        var p = DraftSet2.prototype;
        Object.defineProperty(p, "size", {
          get: function get2() {
            return latest(this[DRAFT_STATE]).size;
          }
        });
        p.has = function(value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!state.copy_) {
            return state.base_.has(value);
          }
          if (state.copy_.has(value))
            return true;
          if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))
            return true;
          return false;
        };
        p.add = function(value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!this.has(value)) {
            prepareSetCopy(state);
            markChanged(state);
            state.copy_.add(value);
          }
          return this;
        };
        p.delete = function(value) {
          if (!this.has(value)) {
            return false;
          }
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          markChanged(state);
          return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : false);
        };
        p.clear = function() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (latest(state).size) {
            prepareSetCopy(state);
            markChanged(state);
            state.copy_.clear();
          }
        };
        p.values = function() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          return state.copy_.values();
        };
        p.entries = function entries() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          return state.copy_.entries();
        };
        p.keys = function() {
          return this.values();
        };
        p[iteratorSymbol] = function() {
          return this.values();
        };
        p.forEach = function forEach(cb, thisArg) {
          var iterator = this.values();
          var result = iterator.next();
          while (!result.done) {
            cb.call(thisArg, result.value, result.value, this);
            result = iterator.next();
          }
        };
        return DraftSet2;
      }(Set);
      function proxySet_(target, parent) {
        return new DraftSet(target, parent);
      }
      function prepareSetCopy(state) {
        if (!state.copy_) {
          state.copy_ = /* @__PURE__ */ new Set();
          state.base_.forEach(function(value) {
            if (isDraftable(value)) {
              var draft = createProxy(state.scope_.immer_, value, state);
              state.drafts_.set(value, draft);
              state.copy_.add(draft);
            } else {
              state.copy_.add(value);
            }
          });
        }
      }
      function assertUnrevoked(state) {
        if (state.revoked_)
          die(3, JSON.stringify(latest(state)));
      }
      loadPlugin("MapSet", {
        proxyMap_,
        proxySet_
      });
    }
    function enableAllPlugins() {
      enableES5();
      enableMapSet();
      enablePatches();
    }
    var immer = new Immer();
    var produce = immer.produce;
    var produceWithPatches = immer.produceWithPatches.bind(immer);
    var setAutoFreeze = immer.setAutoFreeze.bind(immer);
    var setUseProxies = immer.setUseProxies.bind(immer);
    var applyPatches = immer.applyPatches.bind(immer);
    var createDraft = immer.createDraft.bind(immer);
    var finishDraft = immer.finishDraft.bind(immer);
    function castDraft(value) {
      return value;
    }
    function castImmutable(value) {
      return value;
    }
    exports.Immer = Immer;
    exports.applyPatches = applyPatches;
    exports.castDraft = castDraft;
    exports.castImmutable = castImmutable;
    exports.createDraft = createDraft;
    exports.current = current;
    exports.default = produce;
    exports.enableAllPlugins = enableAllPlugins;
    exports.enableES5 = enableES5;
    exports.enableMapSet = enableMapSet;
    exports.enablePatches = enablePatches;
    exports.finishDraft = finishDraft;
    exports.freeze = freeze;
    exports.immerable = DRAFTABLE;
    exports.isDraft = isDraft;
    exports.isDraftable = isDraftable;
    exports.nothing = NOTHING;
    exports.original = original;
    exports.produce = produce;
    exports.produceWithPatches = produceWithPatches;
    exports.setAutoFreeze = setAutoFreeze;
    exports.setUseProxies = setUseProxies;
  }
});

// node_modules/immer/dist/index.js
var require_dist = __commonJS({
  "node_modules/immer/dist/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_immer_cjs_development();
    }
  }
});

// node_modules/@reduxjs/toolkit/dist/query/rtk-query.cjs.development.js
var require_rtk_query_cjs_development = __commonJS({
  "node_modules/@reduxjs/toolkit/dist/query/rtk-query.cjs.development.js"(exports) {
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = function(obj, key, value) {
      return key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    };
    var __spreadValues = function(a, b) {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var _i = 0, _e = __getOwnPropSymbols(b); _i < _e.length; _i++) {
          var prop = _e[_i];
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = function(a, b) {
      return __defProps(a, __getOwnPropDescs(b));
    };
    var __markAsModule = function(target) {
      return __defProp(target, "__esModule", { value: true });
    };
    var __objRest = function(source, exclude) {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols)
        for (var _i = 0, _e = __getOwnPropSymbols(source); _i < _e.length; _i++) {
          var prop = _e[_i];
          if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    var __export = function(target, all) {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __reExport = function(target, module2, desc) {
      if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        var _loop_1 = function(key2) {
          if (!__hasOwnProp.call(target, key2) && key2 !== "default")
            __defProp(target, key2, { get: function() {
              return module2[key2];
            }, enumerable: !(desc = __getOwnPropDesc(module2, key2)) || desc.enumerable });
        };
        for (var _i = 0, _e = __getOwnPropNames(module2); _i < _e.length; _i++) {
          var key = _e[_i];
          _loop_1(key);
        }
      }
      return target;
    };
    var __toModule = function(module2) {
      return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: function() {
        return module2.default;
      }, enumerable: true } : { value: module2, enumerable: true })), module2);
    };
    var __async = function(__this, __arguments, generator) {
      return new Promise(function(resolve, reject) {
        var fulfilled = function(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = function(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = function(x) {
          return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        };
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    __markAsModule(exports);
    __export(exports, {
      QueryStatus: function() {
        return QueryStatus;
      },
      buildCreateApi: function() {
        return buildCreateApi;
      },
      copyWithStructuralSharing: function() {
        return copyWithStructuralSharing;
      },
      coreModule: function() {
        return coreModule;
      },
      createApi: function() {
        return createApi;
      },
      fakeBaseQuery: function() {
        return fakeBaseQuery;
      },
      fetchBaseQuery: function() {
        return fetchBaseQuery;
      },
      retry: function() {
        return retry;
      },
      setupListeners: function() {
        return setupListeners;
      },
      skipSelector: function() {
        return skipSelector;
      },
      skipToken: function() {
        return skipToken;
      }
    });
    var QueryStatus;
    (function(QueryStatus2) {
      QueryStatus2["uninitialized"] = "uninitialized";
      QueryStatus2["pending"] = "pending";
      QueryStatus2["fulfilled"] = "fulfilled";
      QueryStatus2["rejected"] = "rejected";
    })(QueryStatus || (QueryStatus = {}));
    function getRequestStatusFlags(status) {
      return {
        status,
        isUninitialized: status === QueryStatus.uninitialized,
        isLoading: status === QueryStatus.pending,
        isSuccess: status === QueryStatus.fulfilled,
        isError: status === QueryStatus.rejected
      };
    }
    function isAbsoluteUrl(url) {
      return new RegExp("(^|:)//").test(url);
    }
    var withoutTrailingSlash = function(url) {
      return url.replace(/\/$/, "");
    };
    var withoutLeadingSlash = function(url) {
      return url.replace(/^\//, "");
    };
    function joinUrls(base, url) {
      if (!base) {
        return url;
      }
      if (!url) {
        return base;
      }
      if (isAbsoluteUrl(url)) {
        return url;
      }
      var delimiter = base.endsWith("/") || !url.startsWith("?") ? "/" : "";
      base = withoutTrailingSlash(base);
      url = withoutLeadingSlash(url);
      return "" + base + delimiter + url;
    }
    var flatten = function(arr) {
      return [].concat.apply([], arr);
    };
    function isOnline() {
      return typeof navigator === "undefined" ? true : navigator.onLine === void 0 ? true : navigator.onLine;
    }
    function isDocumentVisible() {
      if (typeof document === "undefined") {
        return true;
      }
      return document.visibilityState !== "hidden";
    }
    var import_toolkit = __toModule((init_redux_toolkit_esm(), __toCommonJS(redux_toolkit_esm_exports)));
    var isPlainObject = import_toolkit.isPlainObject;
    function copyWithStructuralSharing(oldObj, newObj) {
      if (oldObj === newObj || !(isPlainObject(oldObj) && isPlainObject(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {
        return newObj;
      }
      var newKeys = Object.keys(newObj);
      var oldKeys = Object.keys(oldObj);
      var isSameObject = newKeys.length === oldKeys.length;
      var mergeObj = Array.isArray(newObj) ? [] : {};
      for (var _i = 0, newKeys_1 = newKeys; _i < newKeys_1.length; _i++) {
        var key = newKeys_1[_i];
        mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);
        if (isSameObject)
          isSameObject = oldObj[key] === mergeObj[key];
      }
      return isSameObject ? oldObj : mergeObj;
    }
    var import_toolkit2 = __toModule((init_redux_toolkit_esm(), __toCommonJS(redux_toolkit_esm_exports)));
    var defaultFetchFn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return fetch.apply(void 0, args);
    };
    var defaultValidateStatus = function(response) {
      return response.status >= 200 && response.status <= 299;
    };
    var isJsonContentType = function(headers) {
      var _a, _b;
      return (_b = (_a = headers.get("content-type")) == null ? void 0 : _a.trim()) == null ? void 0 : _b.startsWith("application/json");
    };
    var handleResponse = function(response, responseHandler) {
      return __async(void 0, null, function() {
        var text;
        return __generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              if (typeof responseHandler === "function") {
                return [2, responseHandler(response)];
              }
              if (responseHandler === "text") {
                return [2, response.text()];
              }
              if (!(responseHandler === "json"))
                return [3, 2];
              return [4, response.text()];
            case 1:
              text = _e.sent();
              return [2, text.length ? JSON.parse(text) : null];
            case 2:
              return [2];
          }
        });
      });
    };
    function stripUndefined(obj) {
      if (!(0, import_toolkit2.isPlainObject)(obj)) {
        return obj;
      }
      var copy = __spreadValues({}, obj);
      for (var _i = 0, _e = Object.entries(copy); _i < _e.length; _i++) {
        var _f = _e[_i], k = _f[0], v = _f[1];
        if (v === void 0)
          delete copy[k];
      }
      return copy;
    }
    function fetchBaseQuery(_a) {
      var _this = this;
      if (_a === void 0) {
        _a = {};
      }
      var _b = _a, baseUrl = _b.baseUrl, _e = _b.prepareHeaders, prepareHeaders = _e === void 0 ? function(x) {
        return x;
      } : _e, _f = _b.fetchFn, fetchFn = _f === void 0 ? defaultFetchFn : _f, paramsSerializer = _b.paramsSerializer, baseFetchOptions = __objRest(_b, [
        "baseUrl",
        "prepareHeaders",
        "fetchFn",
        "paramsSerializer"
      ]);
      if (typeof fetch === "undefined" && fetchFn === defaultFetchFn) {
        console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.");
      }
      return function(arg, api) {
        return __async(_this, null, function() {
          var signal, getState, extra, endpoint, forced, type, meta, _a2, url, _e2, method, _f2, headers, _g, body, _h, params, _j, responseHandler, _k, validateStatus, rest, config, _l, isJsonifiable, divider, query, request, requestClone, response, e_1, responseClone, resultData, responseText, handleResponseError_1, e_2;
          return __generator(this, function(_m) {
            switch (_m.label) {
              case 0:
                signal = api.signal, getState = api.getState, extra = api.extra, endpoint = api.endpoint, forced = api.forced, type = api.type;
                _a2 = typeof arg == "string" ? { url: arg } : arg, url = _a2.url, _e2 = _a2.method, method = _e2 === void 0 ? "GET" : _e2, _f2 = _a2.headers, headers = _f2 === void 0 ? new Headers({}) : _f2, _g = _a2.body, body = _g === void 0 ? void 0 : _g, _h = _a2.params, params = _h === void 0 ? void 0 : _h, _j = _a2.responseHandler, responseHandler = _j === void 0 ? "json" : _j, _k = _a2.validateStatus, validateStatus = _k === void 0 ? defaultValidateStatus : _k, rest = __objRest(_a2, [
                  "url",
                  "method",
                  "headers",
                  "body",
                  "params",
                  "responseHandler",
                  "validateStatus"
                ]);
                config = __spreadValues(__spreadProps(__spreadValues({}, baseFetchOptions), {
                  method,
                  signal,
                  body
                }), rest);
                _l = config;
                return [4, prepareHeaders(new Headers(stripUndefined(headers)), { getState, extra, endpoint, forced, type })];
              case 1:
                _l.headers = _m.sent();
                isJsonifiable = function(body2) {
                  return typeof body2 === "object" && ((0, import_toolkit2.isPlainObject)(body2) || Array.isArray(body2) || typeof body2.toJSON === "function");
                };
                if (!config.headers.has("content-type") && isJsonifiable(body)) {
                  config.headers.set("content-type", "application/json");
                }
                if (isJsonifiable(body) && isJsonContentType(config.headers)) {
                  config.body = JSON.stringify(body);
                }
                if (params) {
                  divider = ~url.indexOf("?") ? "&" : "?";
                  query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));
                  url += divider + query;
                }
                url = joinUrls(baseUrl, url);
                request = new Request(url, config);
                requestClone = request.clone();
                meta = { request: requestClone };
                _m.label = 2;
              case 2:
                _m.trys.push([2, 4, , 5]);
                return [4, fetchFn(request)];
              case 3:
                response = _m.sent();
                return [3, 5];
              case 4:
                e_1 = _m.sent();
                return [2, { error: { status: "FETCH_ERROR", error: String(e_1) }, meta }];
              case 5:
                responseClone = response.clone();
                meta.response = responseClone;
                responseText = "";
                _m.label = 6;
              case 6:
                _m.trys.push([6, 8, , 9]);
                return [4, Promise.all([
                  handleResponse(response, responseHandler).then(function(r) {
                    return resultData = r;
                  }, function(e) {
                    return handleResponseError_1 = e;
                  }),
                  responseClone.text().then(function(r) {
                    return responseText = r;
                  }, function() {
                  })
                ])];
              case 7:
                _m.sent();
                if (handleResponseError_1)
                  throw handleResponseError_1;
                return [3, 9];
              case 8:
                e_2 = _m.sent();
                return [2, {
                  error: {
                    status: "PARSING_ERROR",
                    originalStatus: response.status,
                    data: responseText,
                    error: String(e_2)
                  },
                  meta
                }];
              case 9:
                return [2, validateStatus(response, resultData) ? {
                  data: resultData,
                  meta
                } : {
                  error: {
                    status: response.status,
                    data: resultData
                  },
                  meta
                }];
            }
          });
        });
      };
    }
    var HandledError = function() {
      function HandledError2(value, meta) {
        if (meta === void 0) {
          meta = void 0;
        }
        this.value = value;
        this.meta = meta;
      }
      return HandledError2;
    }();
    function defaultBackoff(attempt, maxRetries) {
      if (attempt === void 0) {
        attempt = 0;
      }
      if (maxRetries === void 0) {
        maxRetries = 5;
      }
      return __async(this, null, function() {
        var attempts, timeout;
        return __generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              attempts = Math.min(attempt, maxRetries);
              timeout = ~~((Math.random() + 0.4) * (300 << attempts));
              return [4, new Promise(function(resolve) {
                return setTimeout(function(res) {
                  return resolve(res);
                }, timeout);
              })];
            case 1:
              _e.sent();
              return [2];
          }
        });
      });
    }
    function fail(e) {
      throw Object.assign(new HandledError({ error: e }), {
        throwImmediately: true
      });
    }
    var retryWithBackoff = function(baseQuery, defaultOptions) {
      return function(args, api, extraOptions) {
        return __async(void 0, null, function() {
          var options, retry2, result, e_3;
          return __generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                options = __spreadValues(__spreadValues({
                  maxRetries: 5,
                  backoff: defaultBackoff
                }, defaultOptions), extraOptions);
                retry2 = 0;
                _e.label = 1;
              case 1:
                if (false)
                  return [3, 7];
                _e.label = 2;
              case 2:
                _e.trys.push([2, 4, , 6]);
                return [4, baseQuery(args, api, extraOptions)];
              case 3:
                result = _e.sent();
                if (result.error) {
                  throw new HandledError(result);
                }
                return [2, result];
              case 4:
                e_3 = _e.sent();
                retry2++;
                if (e_3.throwImmediately || retry2 > options.maxRetries) {
                  if (e_3 instanceof HandledError) {
                    return [2, e_3.value];
                  }
                  throw e_3;
                }
                return [4, options.backoff(retry2, options.maxRetries)];
              case 5:
                _e.sent();
                return [3, 6];
              case 6:
                return [3, 1];
              case 7:
                return [2];
            }
          });
        });
      };
    };
    var retry = Object.assign(retryWithBackoff, { fail });
    var import_toolkit3 = __toModule((init_redux_toolkit_esm(), __toCommonJS(redux_toolkit_esm_exports)));
    var onFocus = (0, import_toolkit3.createAction)("__rtkq/focused");
    var onFocusLost = (0, import_toolkit3.createAction)("__rtkq/unfocused");
    var onOnline = (0, import_toolkit3.createAction)("__rtkq/online");
    var onOffline = (0, import_toolkit3.createAction)("__rtkq/offline");
    var initialized = false;
    function setupListeners(dispatch, customHandler) {
      function defaultHandler() {
        var handleFocus = function() {
          return dispatch(onFocus());
        };
        var handleFocusLost = function() {
          return dispatch(onFocusLost());
        };
        var handleOnline = function() {
          return dispatch(onOnline());
        };
        var handleOffline = function() {
          return dispatch(onOffline());
        };
        var handleVisibilityChange = function() {
          if (window.document.visibilityState === "visible") {
            handleFocus();
          } else {
            handleFocusLost();
          }
        };
        if (!initialized) {
          if (typeof window !== "undefined" && window.addEventListener) {
            window.addEventListener("visibilitychange", handleVisibilityChange, false);
            window.addEventListener("focus", handleFocus, false);
            window.addEventListener("online", handleOnline, false);
            window.addEventListener("offline", handleOffline, false);
            initialized = true;
          }
        }
        var unsubscribe = function() {
          window.removeEventListener("focus", handleFocus);
          window.removeEventListener("visibilitychange", handleVisibilityChange);
          window.removeEventListener("online", handleOnline);
          window.removeEventListener("offline", handleOffline);
          initialized = false;
        };
        return unsubscribe;
      }
      return customHandler ? customHandler(dispatch, { onFocus, onFocusLost, onOffline, onOnline }) : defaultHandler();
    }
    var import_toolkit7 = __toModule((init_redux_toolkit_esm(), __toCommonJS(redux_toolkit_esm_exports)));
    var DefinitionType;
    (function(DefinitionType2) {
      DefinitionType2["query"] = "query";
      DefinitionType2["mutation"] = "mutation";
    })(DefinitionType || (DefinitionType = {}));
    function isQueryDefinition(e) {
      return e.type === DefinitionType.query;
    }
    function isMutationDefinition(e) {
      return e.type === DefinitionType.mutation;
    }
    function calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {
      if (isFunction(description)) {
        return description(result, error, queryArg, meta).map(expandTagDescription).map(assertTagTypes);
      }
      if (Array.isArray(description)) {
        return description.map(expandTagDescription).map(assertTagTypes);
      }
      return [];
    }
    function isFunction(t) {
      return typeof t === "function";
    }
    function expandTagDescription(description) {
      return typeof description === "string" ? { type: description } : description;
    }
    var import_toolkit6 = __toModule((init_redux_toolkit_esm(), __toCommonJS(redux_toolkit_esm_exports)));
    var import_toolkit4 = __toModule((init_redux_toolkit_esm(), __toCommonJS(redux_toolkit_esm_exports)));
    var import_immer = __toModule(require_dist());
    var import_toolkit5 = __toModule((init_redux_toolkit_esm(), __toCommonJS(redux_toolkit_esm_exports)));
    function defaultTransformResponse(baseQueryReturnValue) {
      return baseQueryReturnValue;
    }
    function buildThunks(_e) {
      var _this = this;
      var reducerPath = _e.reducerPath, baseQuery = _e.baseQuery, endpointDefinitions = _e.context.endpointDefinitions, serializeQueryArgs = _e.serializeQueryArgs, api = _e.api;
      var patchQueryData = function(endpointName, args, patches) {
        return function(dispatch) {
          var endpointDefinition = endpointDefinitions[endpointName];
          dispatch(api.internalActions.queryResultPatched({
            queryCacheKey: serializeQueryArgs({
              queryArgs: args,
              endpointDefinition,
              endpointName
            }),
            patches
          }));
        };
      };
      var updateQueryData = function(endpointName, args, updateRecipe) {
        return function(dispatch, getState) {
          var _e2, _f;
          var currentState = api.endpoints[endpointName].select(args)(getState());
          var ret = {
            patches: [],
            inversePatches: [],
            undo: function() {
              return dispatch(api.util.patchQueryData(endpointName, args, ret.inversePatches));
            }
          };
          if (currentState.status === QueryStatus.uninitialized) {
            return ret;
          }
          if ("data" in currentState) {
            if ((0, import_immer.isDraftable)(currentState.data)) {
              var _g = (0, import_immer.produceWithPatches)(currentState.data, updateRecipe), patches = _g[1], inversePatches = _g[2];
              (_e2 = ret.patches).push.apply(_e2, patches);
              (_f = ret.inversePatches).push.apply(_f, inversePatches);
            } else {
              var value = updateRecipe(currentState.data);
              ret.patches.push({ op: "replace", path: [], value });
              ret.inversePatches.push({
                op: "replace",
                path: [],
                value: currentState.data
              });
            }
          }
          dispatch(api.util.patchQueryData(endpointName, args, ret.patches));
          return ret;
        };
      };
      var executeEndpoint = function(_0, _1) {
        return __async(_this, [_0, _1], function(arg, _e2) {
          var endpointDefinition, transformResponse, result, baseQueryApi_1, what, err, _i, _f, key, _g, error_1;
          var signal = _e2.signal, rejectWithValue = _e2.rejectWithValue, fulfillWithValue = _e2.fulfillWithValue, dispatch = _e2.dispatch, getState = _e2.getState, extra = _e2.extra;
          return __generator(this, function(_h) {
            switch (_h.label) {
              case 0:
                endpointDefinition = endpointDefinitions[arg.endpointName];
                _h.label = 1;
              case 1:
                _h.trys.push([1, 7, , 8]);
                transformResponse = defaultTransformResponse;
                result = void 0;
                baseQueryApi_1 = {
                  signal,
                  dispatch,
                  getState,
                  extra,
                  endpoint: arg.endpointName,
                  type: arg.type,
                  forced: arg.type === "query" ? isForcedQuery(arg, getState()) : void 0
                };
                if (!endpointDefinition.query)
                  return [3, 3];
                return [4, baseQuery(endpointDefinition.query(arg.originalArgs), baseQueryApi_1, endpointDefinition.extraOptions)];
              case 2:
                result = _h.sent();
                if (endpointDefinition.transformResponse) {
                  transformResponse = endpointDefinition.transformResponse;
                }
                return [3, 5];
              case 3:
                return [4, endpointDefinition.queryFn(arg.originalArgs, baseQueryApi_1, endpointDefinition.extraOptions, function(arg2) {
                  return baseQuery(arg2, baseQueryApi_1, endpointDefinition.extraOptions);
                })];
              case 4:
                result = _h.sent();
                _h.label = 5;
              case 5:
                if (typeof process !== "undefined" && true) {
                  what = endpointDefinition.query ? "`baseQuery`" : "`queryFn`";
                  err = void 0;
                  if (!result) {
                    err = what + " did not return anything.";
                  } else if (typeof result !== "object") {
                    err = what + " did not return an object.";
                  } else if (result.error && result.data) {
                    err = what + " returned an object containing both `error` and `result`.";
                  } else if (result.error === void 0 && result.data === void 0) {
                    err = what + " returned an object containing neither a valid `error` and `result`. At least one of them should not be `undefined`";
                  } else {
                    for (_i = 0, _f = Object.keys(result); _i < _f.length; _i++) {
                      key = _f[_i];
                      if (key !== "error" && key !== "data" && key !== "meta") {
                        err = "The object returned by " + what + " has the unknown property " + key + ".";
                        break;
                      }
                    }
                  }
                  if (err) {
                    console.error("Error encountered handling the endpoint " + arg.endpointName + ".\n              " + err + "\n              It needs to return an object with either the shape `{ data: <value> }` or `{ error: <value> }` that may contain an optional `meta` property.\n              Object returned was:", result);
                  }
                }
                if (result.error)
                  throw new HandledError(result.error, result.meta);
                _g = fulfillWithValue;
                return [4, transformResponse(result.data, result.meta, arg.originalArgs)];
              case 6:
                return [2, _g.apply(void 0, [_h.sent(), {
                  fulfilledTimeStamp: Date.now(),
                  baseQueryMeta: result.meta
                }])];
              case 7:
                error_1 = _h.sent();
                if (error_1 instanceof HandledError) {
                  return [2, rejectWithValue(error_1.value, { baseQueryMeta: error_1.meta })];
                }
                if (typeof process !== "undefined" && true) {
                  console.error('An unhandled error occurred processing a request for the endpoint "' + arg.endpointName + '".\nIn the case of an unhandled error, no tags will be "provided" or "invalidated".', error_1);
                } else {
                  console.error(error_1);
                }
                throw error_1;
              case 8:
                return [2];
            }
          });
        });
      };
      function isForcedQuery(arg, state) {
        var _a, _b, _c, _d;
        var requestState = (_b = (_a = state[reducerPath]) == null ? void 0 : _a.queries) == null ? void 0 : _b[arg.queryCacheKey];
        var baseFetchOnMountOrArgChange = (_c = state[reducerPath]) == null ? void 0 : _c.config.refetchOnMountOrArgChange;
        var fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;
        var refetchVal = (_d = arg.forceRefetch) != null ? _d : arg.subscribe && baseFetchOnMountOrArgChange;
        if (refetchVal) {
          return refetchVal === true || (Number(new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;
        }
        return false;
      }
      var queryThunk = (0, import_toolkit5.createAsyncThunk)(reducerPath + "/executeQuery", executeEndpoint, {
        getPendingMeta: function() {
          return { startedTimeStamp: Date.now() };
        },
        condition: function(arg, _e2) {
          var getState = _e2.getState;
          var _a, _b;
          var state = getState();
          var requestState = (_b = (_a = state[reducerPath]) == null ? void 0 : _a.queries) == null ? void 0 : _b[arg.queryCacheKey];
          var fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;
          if ((requestState == null ? void 0 : requestState.status) === "pending")
            return false;
          if (isForcedQuery(arg, state))
            return true;
          if (fulfilledVal)
            return false;
          return true;
        },
        dispatchConditionRejection: true
      });
      var mutationThunk = (0, import_toolkit5.createAsyncThunk)(reducerPath + "/executeMutation", executeEndpoint, {
        getPendingMeta: function() {
          return { startedTimeStamp: Date.now() };
        }
      });
      var hasTheForce = function(options) {
        return "force" in options;
      };
      var hasMaxAge = function(options) {
        return "ifOlderThan" in options;
      };
      var prefetch = function(endpointName, arg, options) {
        return function(dispatch, getState) {
          var force = hasTheForce(options) && options.force;
          var maxAge = hasMaxAge(options) && options.ifOlderThan;
          var queryAction = function(force2) {
            if (force2 === void 0) {
              force2 = true;
            }
            return api.endpoints[endpointName].initiate(arg, { forceRefetch: force2 });
          };
          var latestStateValue = api.endpoints[endpointName].select(arg)(getState());
          if (force) {
            dispatch(queryAction());
          } else if (maxAge) {
            var lastFulfilledTs = latestStateValue == null ? void 0 : latestStateValue.fulfilledTimeStamp;
            if (!lastFulfilledTs) {
              dispatch(queryAction());
              return;
            }
            var shouldRetrigger = (Number(new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;
            if (shouldRetrigger) {
              dispatch(queryAction());
            }
          } else {
            dispatch(queryAction(false));
          }
        };
      };
      function matchesEndpoint(endpointName) {
        return function(action) {
          var _a, _b;
          return ((_b = (_a = action == null ? void 0 : action.meta) == null ? void 0 : _a.arg) == null ? void 0 : _b.endpointName) === endpointName;
        };
      }
      function buildMatchThunkActions(thunk, endpointName) {
        return {
          matchPending: (0, import_toolkit4.isAllOf)((0, import_toolkit4.isPending)(thunk), matchesEndpoint(endpointName)),
          matchFulfilled: (0, import_toolkit4.isAllOf)((0, import_toolkit4.isFulfilled)(thunk), matchesEndpoint(endpointName)),
          matchRejected: (0, import_toolkit4.isAllOf)((0, import_toolkit4.isRejected)(thunk), matchesEndpoint(endpointName))
        };
      }
      return {
        queryThunk,
        mutationThunk,
        prefetch,
        updateQueryData,
        patchQueryData,
        buildMatchThunkActions
      };
    }
    function calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {
      return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], (0, import_toolkit4.isFulfilled)(action) ? action.payload : void 0, (0, import_toolkit4.isRejectedWithValue)(action) ? action.payload : void 0, action.meta.arg.originalArgs, "baseQueryMeta" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);
    }
    var import_immer2 = __toModule(require_dist());
    function updateQuerySubstateIfExists(state, queryCacheKey, update) {
      var substate = state[queryCacheKey];
      if (substate) {
        update(substate);
      }
    }
    function getMutationCacheKey(id) {
      var _a;
      return (_a = "arg" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) != null ? _a : id.requestId;
    }
    function updateMutationSubstateIfExists(state, id, update) {
      var substate = state[getMutationCacheKey(id)];
      if (substate) {
        update(substate);
      }
    }
    var initialState = {};
    function buildSlice(_e) {
      var reducerPath = _e.reducerPath, queryThunk = _e.queryThunk, mutationThunk = _e.mutationThunk, _f = _e.context, definitions = _f.endpointDefinitions, apiUid = _f.apiUid, extractRehydrationInfo = _f.extractRehydrationInfo, hasRehydrationInfo = _f.hasRehydrationInfo, assertTagType = _e.assertTagType, config = _e.config;
      var resetApiState = (0, import_toolkit6.createAction)(reducerPath + "/resetApiState");
      var querySlice = (0, import_toolkit6.createSlice)({
        name: reducerPath + "/queries",
        initialState,
        reducers: {
          removeQueryResult: function(draft, _e2) {
            var queryCacheKey = _e2.payload.queryCacheKey;
            delete draft[queryCacheKey];
          },
          queryResultPatched: function(draft, _e2) {
            var _f2 = _e2.payload, queryCacheKey = _f2.queryCacheKey, patches = _f2.patches;
            updateQuerySubstateIfExists(draft, queryCacheKey, function(substate) {
              substate.data = (0, import_immer2.applyPatches)(substate.data, patches.concat());
            });
          }
        },
        extraReducers: function(builder) {
          builder.addCase(queryThunk.pending, function(draft, _e2) {
            var meta = _e2.meta, arg = _e2.meta.arg;
            var _a, _b;
            if (arg.subscribe) {
              (_b = draft[_a = arg.queryCacheKey]) != null ? _b : draft[_a] = {
                status: QueryStatus.uninitialized,
                endpointName: arg.endpointName
              };
            }
            updateQuerySubstateIfExists(draft, arg.queryCacheKey, function(substate) {
              substate.status = QueryStatus.pending;
              substate.requestId = meta.requestId;
              if (arg.originalArgs !== void 0) {
                substate.originalArgs = arg.originalArgs;
              }
              substate.startedTimeStamp = meta.startedTimeStamp;
            });
          }).addCase(queryThunk.fulfilled, function(draft, _e2) {
            var meta = _e2.meta, payload = _e2.payload;
            updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, function(substate) {
              var _a;
              if (substate.requestId !== meta.requestId)
                return;
              substate.status = QueryStatus.fulfilled;
              substate.data = ((_a = definitions[meta.arg.endpointName].structuralSharing) != null ? _a : true) ? copyWithStructuralSharing(substate.data, payload) : payload;
              delete substate.error;
              substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
            });
          }).addCase(queryThunk.rejected, function(draft, _e2) {
            var _f2 = _e2.meta, condition = _f2.condition, arg = _f2.arg, requestId = _f2.requestId, error = _e2.error, payload = _e2.payload;
            updateQuerySubstateIfExists(draft, arg.queryCacheKey, function(substate) {
              if (condition) {
              } else {
                if (substate.requestId !== requestId)
                  return;
                substate.status = QueryStatus.rejected;
                substate.error = payload != null ? payload : error;
              }
            });
          }).addMatcher(hasRehydrationInfo, function(draft, action) {
            var queries = extractRehydrationInfo(action).queries;
            for (var _i = 0, _e2 = Object.entries(queries); _i < _e2.length; _i++) {
              var _f2 = _e2[_i], key = _f2[0], entry = _f2[1];
              if ((entry == null ? void 0 : entry.status) === QueryStatus.fulfilled || (entry == null ? void 0 : entry.status) === QueryStatus.rejected) {
                draft[key] = entry;
              }
            }
          });
        }
      });
      var mutationSlice = (0, import_toolkit6.createSlice)({
        name: reducerPath + "/mutations",
        initialState,
        reducers: {
          removeMutationResult: function(draft, _e2) {
            var payload = _e2.payload;
            var cacheKey = getMutationCacheKey(payload);
            if (cacheKey in draft) {
              delete draft[cacheKey];
            }
          }
        },
        extraReducers: function(builder) {
          builder.addCase(mutationThunk.pending, function(draft, _e2) {
            var meta = _e2.meta, _f2 = _e2.meta, requestId = _f2.requestId, arg = _f2.arg, startedTimeStamp = _f2.startedTimeStamp;
            if (!arg.track)
              return;
            draft[getMutationCacheKey(meta)] = {
              requestId,
              status: QueryStatus.pending,
              endpointName: arg.endpointName,
              startedTimeStamp
            };
          }).addCase(mutationThunk.fulfilled, function(draft, _e2) {
            var payload = _e2.payload, meta = _e2.meta;
            if (!meta.arg.track)
              return;
            updateMutationSubstateIfExists(draft, meta, function(substate) {
              if (substate.requestId !== meta.requestId)
                return;
              substate.status = QueryStatus.fulfilled;
              substate.data = payload;
              substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
            });
          }).addCase(mutationThunk.rejected, function(draft, _e2) {
            var payload = _e2.payload, error = _e2.error, meta = _e2.meta;
            if (!meta.arg.track)
              return;
            updateMutationSubstateIfExists(draft, meta, function(substate) {
              if (substate.requestId !== meta.requestId)
                return;
              substate.status = QueryStatus.rejected;
              substate.error = payload != null ? payload : error;
            });
          }).addMatcher(hasRehydrationInfo, function(draft, action) {
            var mutations = extractRehydrationInfo(action).mutations;
            for (var _i = 0, _e2 = Object.entries(mutations); _i < _e2.length; _i++) {
              var _f2 = _e2[_i], key = _f2[0], entry = _f2[1];
              if (((entry == null ? void 0 : entry.status) === QueryStatus.fulfilled || (entry == null ? void 0 : entry.status) === QueryStatus.rejected) && key !== (entry == null ? void 0 : entry.requestId)) {
                draft[key] = entry;
              }
            }
          });
        }
      });
      var invalidationSlice = (0, import_toolkit6.createSlice)({
        name: reducerPath + "/invalidation",
        initialState,
        reducers: {},
        extraReducers: function(builder) {
          builder.addCase(querySlice.actions.removeQueryResult, function(draft, _e2) {
            var queryCacheKey = _e2.payload.queryCacheKey;
            for (var _i = 0, _f2 = Object.values(draft); _i < _f2.length; _i++) {
              var tagTypeSubscriptions = _f2[_i];
              for (var _g = 0, _h = Object.values(tagTypeSubscriptions); _g < _h.length; _g++) {
                var idSubscriptions = _h[_g];
                var foundAt = idSubscriptions.indexOf(queryCacheKey);
                if (foundAt !== -1) {
                  idSubscriptions.splice(foundAt, 1);
                }
              }
            }
          }).addMatcher(hasRehydrationInfo, function(draft, action) {
            var _a, _b, _c, _d;
            var provided = extractRehydrationInfo(action).provided;
            for (var _i = 0, _e2 = Object.entries(provided); _i < _e2.length; _i++) {
              var _f2 = _e2[_i], type = _f2[0], incomingTags = _f2[1];
              for (var _g = 0, _h = Object.entries(incomingTags); _g < _h.length; _g++) {
                var _j = _h[_g], id = _j[0], cacheKeys = _j[1];
                var subscribedQueries = (_d = (_b = (_a = draft[type]) != null ? _a : draft[type] = {})[_c = id || "__internal_without_id"]) != null ? _d : _b[_c] = [];
                for (var _k = 0, cacheKeys_1 = cacheKeys; _k < cacheKeys_1.length; _k++) {
                  var queryCacheKey = cacheKeys_1[_k];
                  var alreadySubscribed = subscribedQueries.includes(queryCacheKey);
                  if (!alreadySubscribed) {
                    subscribedQueries.push(queryCacheKey);
                  }
                }
              }
            }
          }).addMatcher((0, import_toolkit6.isAnyOf)((0, import_toolkit6.isFulfilled)(queryThunk), (0, import_toolkit6.isRejectedWithValue)(queryThunk)), function(draft, action) {
            var _a, _b, _c, _d;
            var providedTags = calculateProvidedByThunk(action, "providesTags", definitions, assertTagType);
            var queryCacheKey = action.meta.arg.queryCacheKey;
            for (var _i = 0, _e2 = Object.values(draft); _i < _e2.length; _i++) {
              var tagTypeSubscriptions = _e2[_i];
              for (var _f2 = 0, _g = Object.values(tagTypeSubscriptions); _f2 < _g.length; _f2++) {
                var idSubscriptions = _g[_f2];
                var foundAt = idSubscriptions.indexOf(queryCacheKey);
                if (foundAt !== -1) {
                  idSubscriptions.splice(foundAt, 1);
                }
              }
            }
            for (var _h = 0, providedTags_1 = providedTags; _h < providedTags_1.length; _h++) {
              var _j = providedTags_1[_h], type = _j.type, id = _j.id;
              var subscribedQueries = (_d = (_b = (_a = draft[type]) != null ? _a : draft[type] = {})[_c = id || "__internal_without_id"]) != null ? _d : _b[_c] = [];
              var alreadySubscribed = subscribedQueries.includes(queryCacheKey);
              if (!alreadySubscribed) {
                subscribedQueries.push(queryCacheKey);
              }
            }
          });
        }
      });
      var subscriptionSlice = (0, import_toolkit6.createSlice)({
        name: reducerPath + "/subscriptions",
        initialState,
        reducers: {
          updateSubscriptionOptions: function(draft, _e2) {
            var _f2 = _e2.payload, queryCacheKey = _f2.queryCacheKey, requestId = _f2.requestId, options = _f2.options;
            var _a;
            if ((_a = draft == null ? void 0 : draft[queryCacheKey]) == null ? void 0 : _a[requestId]) {
              draft[queryCacheKey][requestId] = options;
            }
          },
          unsubscribeQueryResult: function(draft, _e2) {
            var _f2 = _e2.payload, queryCacheKey = _f2.queryCacheKey, requestId = _f2.requestId;
            if (draft[queryCacheKey]) {
              delete draft[queryCacheKey][requestId];
            }
          }
        },
        extraReducers: function(builder) {
          builder.addCase(querySlice.actions.removeQueryResult, function(draft, _e2) {
            var queryCacheKey = _e2.payload.queryCacheKey;
            delete draft[queryCacheKey];
          }).addCase(queryThunk.pending, function(draft, _e2) {
            var _f2 = _e2.meta, arg = _f2.arg, requestId = _f2.requestId;
            var _a, _b, _c, _d;
            if (arg.subscribe) {
              var substate = (_b = draft[_a = arg.queryCacheKey]) != null ? _b : draft[_a] = {};
              substate[requestId] = (_d = (_c = arg.subscriptionOptions) != null ? _c : substate[requestId]) != null ? _d : {};
            }
          }).addCase(queryThunk.rejected, function(draft, _e2) {
            var _f2 = _e2.meta, condition = _f2.condition, arg = _f2.arg, requestId = _f2.requestId, error = _e2.error, payload = _e2.payload;
            var _a, _b, _c, _d;
            if (condition && arg.subscribe) {
              var substate = (_b = draft[_a = arg.queryCacheKey]) != null ? _b : draft[_a] = {};
              substate[requestId] = (_d = (_c = arg.subscriptionOptions) != null ? _c : substate[requestId]) != null ? _d : {};
            }
          }).addMatcher(hasRehydrationInfo, function(draft) {
            return __spreadValues({}, draft);
          });
        }
      });
      var configSlice = (0, import_toolkit6.createSlice)({
        name: reducerPath + "/config",
        initialState: __spreadValues({
          online: isOnline(),
          focused: isDocumentVisible(),
          middlewareRegistered: false
        }, config),
        reducers: {
          middlewareRegistered: function(state, _e2) {
            var payload = _e2.payload;
            state.middlewareRegistered = state.middlewareRegistered === "conflict" || apiUid !== payload ? "conflict" : true;
          }
        },
        extraReducers: function(builder) {
          builder.addCase(onOnline, function(state) {
            state.online = true;
          }).addCase(onOffline, function(state) {
            state.online = false;
          }).addCase(onFocus, function(state) {
            state.focused = true;
          }).addCase(onFocusLost, function(state) {
            state.focused = false;
          }).addMatcher(hasRehydrationInfo, function(draft) {
            return __spreadValues({}, draft);
          });
        }
      });
      var combinedReducer = (0, import_toolkit6.combineReducers)({
        queries: querySlice.reducer,
        mutations: mutationSlice.reducer,
        provided: invalidationSlice.reducer,
        subscriptions: subscriptionSlice.reducer,
        config: configSlice.reducer
      });
      var reducer = function(state, action) {
        return combinedReducer(resetApiState.match(action) ? void 0 : state, action);
      };
      var actions = __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, configSlice.actions), querySlice.actions), subscriptionSlice.actions), mutationSlice.actions), {
        unsubscribeMutationResult: mutationSlice.actions.removeMutationResult,
        resetApiState
      });
      return { reducer, actions };
    }
    var skipToken = Symbol.for("RTKQ/skipToken");
    var skipSelector = skipToken;
    var initialSubState = {
      status: QueryStatus.uninitialized
    };
    var defaultQuerySubState = (0, import_toolkit7.createNextState)(initialSubState, function() {
    });
    var defaultMutationSubState = (0, import_toolkit7.createNextState)(initialSubState, function() {
    });
    function buildSelectors(_e) {
      var serializeQueryArgs = _e.serializeQueryArgs, reducerPath = _e.reducerPath;
      return { buildQuerySelector, buildMutationSelector, selectInvalidatedBy };
      function withRequestFlags(substate) {
        return __spreadValues(__spreadValues({}, substate), getRequestStatusFlags(substate.status));
      }
      function selectInternalState(rootState) {
        var state = rootState[reducerPath];
        if (true) {
          if (!state) {
            if (selectInternalState.triggered)
              return state;
            selectInternalState.triggered = true;
            console.error("Error: No data found at `state." + reducerPath + "`. Did you forget to add the reducer to the store?");
          }
        }
        return state;
      }
      function buildQuerySelector(endpointName, endpointDefinition) {
        return function(queryArgs) {
          var selectQuerySubState = (0, import_toolkit7.createSelector)(selectInternalState, function(internalState) {
            var _a, _b;
            return (_b = queryArgs === skipToken ? void 0 : (_a = internalState == null ? void 0 : internalState.queries) == null ? void 0 : _a[serializeQueryArgs({
              queryArgs,
              endpointDefinition,
              endpointName
            })]) != null ? _b : defaultQuerySubState;
          });
          return (0, import_toolkit7.createSelector)(selectQuerySubState, withRequestFlags);
        };
      }
      function buildMutationSelector() {
        return function(id) {
          var _a;
          var mutationId;
          if (typeof id === "object") {
            mutationId = (_a = getMutationCacheKey(id)) != null ? _a : skipToken;
          } else {
            mutationId = id;
          }
          var selectMutationSubstate = (0, import_toolkit7.createSelector)(selectInternalState, function(internalState) {
            var _a2, _b;
            return (_b = mutationId === skipToken ? void 0 : (_a2 = internalState == null ? void 0 : internalState.mutations) == null ? void 0 : _a2[mutationId]) != null ? _b : defaultMutationSubState;
          });
          return (0, import_toolkit7.createSelector)(selectMutationSubstate, withRequestFlags);
        };
      }
      function selectInvalidatedBy(state, tags) {
        var _a;
        var apiState = state[reducerPath];
        var toInvalidate = /* @__PURE__ */ new Set();
        for (var _i = 0, _e2 = tags.map(expandTagDescription); _i < _e2.length; _i++) {
          var tag = _e2[_i];
          var provided = apiState.provided[tag.type];
          if (!provided) {
            continue;
          }
          var invalidateSubscriptions = (_a = tag.id !== void 0 ? provided[tag.id] : flatten(Object.values(provided))) != null ? _a : [];
          for (var _f = 0, invalidateSubscriptions_1 = invalidateSubscriptions; _f < invalidateSubscriptions_1.length; _f++) {
            var invalidate = invalidateSubscriptions_1[_f];
            toInvalidate.add(invalidate);
          }
        }
        return flatten(Array.from(toInvalidate.values()).map(function(queryCacheKey) {
          var querySubState = apiState.queries[queryCacheKey];
          return querySubState ? [
            {
              queryCacheKey,
              endpointName: querySubState.endpointName,
              originalArgs: querySubState.originalArgs
            }
          ] : [];
        }));
      }
    }
    var import_toolkit8 = __toModule((init_redux_toolkit_esm(), __toCommonJS(redux_toolkit_esm_exports)));
    var defaultSerializeQueryArgs = function(_e) {
      var endpointName = _e.endpointName, queryArgs = _e.queryArgs;
      return endpointName + "(" + JSON.stringify(queryArgs, function(key, value) {
        return (0, import_toolkit8.isPlainObject)(value) ? Object.keys(value).sort().reduce(function(acc, key2) {
          acc[key2] = value[key2];
          return acc;
        }, {}) : value;
      }) + ")";
    };
    var import_toolkit9 = __toModule((init_redux_toolkit_esm(), __toCommonJS(redux_toolkit_esm_exports)));
    var import_reselect = __toModule((init_es(), __toCommonJS(es_exports)));
    function buildCreateApi() {
      var modules = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        modules[_i] = arguments[_i];
      }
      return function baseCreateApi(options) {
        var extractRehydrationInfo = (0, import_reselect.defaultMemoize)(function(action) {
          var _a, _b;
          return (_b = options.extractRehydrationInfo) == null ? void 0 : _b.call(options, action, {
            reducerPath: (_a = options.reducerPath) != null ? _a : "api"
          });
        });
        var optionsWithDefaults = __spreadProps(__spreadValues({
          reducerPath: "api",
          serializeQueryArgs: defaultSerializeQueryArgs,
          keepUnusedDataFor: 60,
          refetchOnMountOrArgChange: false,
          refetchOnFocus: false,
          refetchOnReconnect: false
        }, options), {
          extractRehydrationInfo,
          tagTypes: __spreadArray([], options.tagTypes || [])
        });
        var context = {
          endpointDefinitions: {},
          batch: function(fn) {
            fn();
          },
          apiUid: (0, import_toolkit9.nanoid)(),
          extractRehydrationInfo,
          hasRehydrationInfo: (0, import_reselect.defaultMemoize)(function(action) {
            return extractRehydrationInfo(action) != null;
          })
        };
        var api = {
          injectEndpoints,
          enhanceEndpoints: function(_e) {
            var addTagTypes = _e.addTagTypes, endpoints = _e.endpoints;
            if (addTagTypes) {
              for (var _i2 = 0, addTagTypes_1 = addTagTypes; _i2 < addTagTypes_1.length; _i2++) {
                var eT = addTagTypes_1[_i2];
                if (!optionsWithDefaults.tagTypes.includes(eT)) {
                  optionsWithDefaults.tagTypes.push(eT);
                }
              }
            }
            if (endpoints) {
              for (var _f = 0, _g = Object.entries(endpoints); _f < _g.length; _f++) {
                var _h = _g[_f], endpointName = _h[0], partialDefinition = _h[1];
                if (typeof partialDefinition === "function") {
                  partialDefinition(context.endpointDefinitions[endpointName]);
                } else {
                  Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);
                }
              }
            }
            return api;
          }
        };
        var initializedModules = modules.map(function(m) {
          return m.init(api, optionsWithDefaults, context);
        });
        function injectEndpoints(inject) {
          var evaluatedEndpoints = inject.endpoints({
            query: function(x) {
              return __spreadProps(__spreadValues({}, x), { type: DefinitionType.query });
            },
            mutation: function(x) {
              return __spreadProps(__spreadValues({}, x), { type: DefinitionType.mutation });
            }
          });
          for (var _i2 = 0, _e = Object.entries(evaluatedEndpoints); _i2 < _e.length; _i2++) {
            var _f = _e[_i2], endpointName = _f[0], definition = _f[1];
            if (!inject.overrideExisting && endpointName in context.endpointDefinitions) {
              if (typeof process !== "undefined" && true) {
                console.error("called `injectEndpoints` to override already-existing endpointName " + endpointName + " without specifying `overrideExisting: true`");
              }
              continue;
            }
            context.endpointDefinitions[endpointName] = definition;
            for (var _g = 0, initializedModules_1 = initializedModules; _g < initializedModules_1.length; _g++) {
              var m = initializedModules_1[_g];
              m.injectEndpoint(endpointName, definition);
            }
          }
          return api;
        }
        return api.injectEndpoints({ endpoints: options.endpoints });
      };
    }
    function fakeBaseQuery() {
      return function() {
        throw new Error("When using `fakeBaseQuery`, all queries & mutations must use the `queryFn` definition syntax.");
      };
    }
    var import_redux = __toModule((init_redux(), __toCommonJS(redux_exports)));
    var import_toolkit13 = __toModule((init_redux_toolkit_esm(), __toCommonJS(redux_toolkit_esm_exports)));
    var THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;
    var build = function(_e) {
      var reducerPath = _e.reducerPath, api = _e.api, context = _e.context;
      var _f = api.internalActions, removeQueryResult = _f.removeQueryResult, unsubscribeQueryResult = _f.unsubscribeQueryResult;
      return function(mwApi) {
        var currentRemovalTimeouts = {};
        return function(next) {
          return function(action) {
            var _a;
            var result = next(action);
            if (unsubscribeQueryResult.match(action)) {
              var state = mwApi.getState()[reducerPath];
              var queryCacheKey = action.payload.queryCacheKey;
              handleUnsubscribe(queryCacheKey, (_a = state.queries[queryCacheKey]) == null ? void 0 : _a.endpointName, mwApi, state.config);
            }
            if (api.util.resetApiState.match(action)) {
              for (var _i = 0, _e2 = Object.entries(currentRemovalTimeouts); _i < _e2.length; _i++) {
                var _f2 = _e2[_i], key = _f2[0], timeout = _f2[1];
                if (timeout)
                  clearTimeout(timeout);
                delete currentRemovalTimeouts[key];
              }
            }
            if (context.hasRehydrationInfo(action)) {
              var state = mwApi.getState()[reducerPath];
              var queries = context.extractRehydrationInfo(action).queries;
              for (var _g = 0, _h = Object.entries(queries); _g < _h.length; _g++) {
                var _j = _h[_g], queryCacheKey = _j[0], queryState = _j[1];
                handleUnsubscribe(queryCacheKey, queryState == null ? void 0 : queryState.endpointName, mwApi, state.config);
              }
            }
            return result;
          };
        };
        function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {
          var _a;
          var endpointDefinition = context.endpointDefinitions[endpointName];
          var keepUnusedDataFor = (_a = endpointDefinition == null ? void 0 : endpointDefinition.keepUnusedDataFor) != null ? _a : config.keepUnusedDataFor;
          var finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));
          var currentTimeout = currentRemovalTimeouts[queryCacheKey];
          if (currentTimeout) {
            clearTimeout(currentTimeout);
          }
          currentRemovalTimeouts[queryCacheKey] = setTimeout(function() {
            var subscriptions = api2.getState()[reducerPath].subscriptions[queryCacheKey];
            if (!subscriptions || Object.keys(subscriptions).length === 0) {
              api2.dispatch(removeQueryResult({ queryCacheKey }));
            }
            delete currentRemovalTimeouts[queryCacheKey];
          }, finalKeepUnusedDataFor * 1e3);
        }
      };
    };
    var import_toolkit10 = __toModule((init_redux_toolkit_esm(), __toCommonJS(redux_toolkit_esm_exports)));
    var build2 = function(_e) {
      var reducerPath = _e.reducerPath, context = _e.context, endpointDefinitions = _e.context.endpointDefinitions, mutationThunk = _e.mutationThunk, api = _e.api, assertTagType = _e.assertTagType, refetchQuery = _e.refetchQuery;
      var removeQueryResult = api.internalActions.removeQueryResult;
      return function(mwApi) {
        return function(next) {
          return function(action) {
            var result = next(action);
            if ((0, import_toolkit10.isAnyOf)((0, import_toolkit10.isFulfilled)(mutationThunk), (0, import_toolkit10.isRejectedWithValue)(mutationThunk))(action)) {
              invalidateTags(calculateProvidedByThunk(action, "invalidatesTags", endpointDefinitions, assertTagType), mwApi);
            }
            if (api.util.invalidateTags.match(action)) {
              invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);
            }
            return result;
          };
        };
      };
      function invalidateTags(tags, mwApi) {
        var rootState = mwApi.getState();
        var state = rootState[reducerPath];
        var toInvalidate = api.util.selectInvalidatedBy(rootState, tags);
        context.batch(function() {
          var _a;
          var valuesArray = Array.from(toInvalidate.values());
          for (var _i = 0, valuesArray_1 = valuesArray; _i < valuesArray_1.length; _i++) {
            var queryCacheKey = valuesArray_1[_i].queryCacheKey;
            var querySubState = state.queries[queryCacheKey];
            var subscriptionSubState = (_a = state.subscriptions[queryCacheKey]) != null ? _a : {};
            if (querySubState) {
              if (Object.keys(subscriptionSubState).length === 0) {
                mwApi.dispatch(removeQueryResult({
                  queryCacheKey
                }));
              } else if (querySubState.status !== QueryStatus.uninitialized) {
                mwApi.dispatch(refetchQuery(querySubState, queryCacheKey));
              }
            }
          }
        });
      }
    };
    var build3 = function(_e) {
      var reducerPath = _e.reducerPath, queryThunk = _e.queryThunk, api = _e.api, refetchQuery = _e.refetchQuery;
      return function(mwApi) {
        var currentPolls = {};
        return function(next) {
          return function(action) {
            var result = next(action);
            if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {
              updatePollingInterval(action.payload, mwApi);
            }
            if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {
              updatePollingInterval(action.meta.arg, mwApi);
            }
            if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {
              startNextPoll(action.meta.arg, mwApi);
            }
            if (api.util.resetApiState.match(action)) {
              clearPolls();
            }
            return result;
          };
        };
        function startNextPoll(_e2, api2) {
          var queryCacheKey = _e2.queryCacheKey;
          var state = api2.getState()[reducerPath];
          var querySubState = state.queries[queryCacheKey];
          var subscriptions = state.subscriptions[queryCacheKey];
          if (!querySubState || querySubState.status === QueryStatus.uninitialized)
            return;
          var lowestPollingInterval = findLowestPollingInterval(subscriptions);
          if (!Number.isFinite(lowestPollingInterval))
            return;
          var currentPoll = currentPolls[queryCacheKey];
          if (currentPoll == null ? void 0 : currentPoll.timeout) {
            clearTimeout(currentPoll.timeout);
            currentPoll.timeout = void 0;
          }
          var nextPollTimestamp = Date.now() + lowestPollingInterval;
          var currentInterval = currentPolls[queryCacheKey] = {
            nextPollTimestamp,
            pollingInterval: lowestPollingInterval,
            timeout: setTimeout(function() {
              currentInterval.timeout = void 0;
              api2.dispatch(refetchQuery(querySubState, queryCacheKey));
            }, lowestPollingInterval)
          };
        }
        function updatePollingInterval(_e2, api2) {
          var queryCacheKey = _e2.queryCacheKey;
          var state = api2.getState()[reducerPath];
          var querySubState = state.queries[queryCacheKey];
          var subscriptions = state.subscriptions[queryCacheKey];
          if (!querySubState || querySubState.status === QueryStatus.uninitialized) {
            return;
          }
          var lowestPollingInterval = findLowestPollingInterval(subscriptions);
          if (!Number.isFinite(lowestPollingInterval)) {
            cleanupPollForKey(queryCacheKey);
            return;
          }
          var currentPoll = currentPolls[queryCacheKey];
          var nextPollTimestamp = Date.now() + lowestPollingInterval;
          if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {
            startNextPoll({ queryCacheKey }, api2);
          }
        }
        function cleanupPollForKey(key) {
          var existingPoll = currentPolls[key];
          if (existingPoll == null ? void 0 : existingPoll.timeout) {
            clearTimeout(existingPoll.timeout);
          }
          delete currentPolls[key];
        }
        function clearPolls() {
          for (var _i = 0, _e2 = Object.keys(currentPolls); _i < _e2.length; _i++) {
            var key = _e2[_i];
            cleanupPollForKey(key);
          }
        }
      };
      function findLowestPollingInterval(subscribers) {
        if (subscribers === void 0) {
          subscribers = {};
        }
        var lowestPollingInterval = Number.POSITIVE_INFINITY;
        for (var _i = 0, _e2 = Object.values(subscribers); _i < _e2.length; _i++) {
          var subscription = _e2[_i];
          if (!!subscription.pollingInterval)
            lowestPollingInterval = Math.min(subscription.pollingInterval, lowestPollingInterval);
        }
        return lowestPollingInterval;
      }
    };
    var build4 = function(_e) {
      var reducerPath = _e.reducerPath, context = _e.context, api = _e.api, refetchQuery = _e.refetchQuery;
      var removeQueryResult = api.internalActions.removeQueryResult;
      return function(mwApi) {
        return function(next) {
          return function(action) {
            var result = next(action);
            if (onFocus.match(action)) {
              refetchValidQueries(mwApi, "refetchOnFocus");
            }
            if (onOnline.match(action)) {
              refetchValidQueries(mwApi, "refetchOnReconnect");
            }
            return result;
          };
        };
      };
      function refetchValidQueries(api2, type) {
        var state = api2.getState()[reducerPath];
        var queries = state.queries;
        var subscriptions = state.subscriptions;
        context.batch(function() {
          for (var _i = 0, _e2 = Object.keys(subscriptions); _i < _e2.length; _i++) {
            var queryCacheKey = _e2[_i];
            var querySubState = queries[queryCacheKey];
            var subscriptionSubState = subscriptions[queryCacheKey];
            if (!subscriptionSubState || !querySubState)
              continue;
            var shouldRefetch = Object.values(subscriptionSubState).some(function(sub) {
              return sub[type] === true;
            }) || Object.values(subscriptionSubState).every(function(sub) {
              return sub[type] === void 0;
            }) && state.config[type];
            if (shouldRefetch) {
              if (Object.keys(subscriptionSubState).length === 0) {
                api2.dispatch(removeQueryResult({
                  queryCacheKey
                }));
              } else if (querySubState.status !== QueryStatus.uninitialized) {
                api2.dispatch(refetchQuery(querySubState, queryCacheKey));
              }
            }
          }
        });
      }
    };
    var import_toolkit11 = __toModule((init_redux_toolkit_esm(), __toCommonJS(redux_toolkit_esm_exports)));
    var neverResolvedError = new Error("Promise never resolved before cacheEntryRemoved.");
    var build5 = function(_e) {
      var api = _e.api, reducerPath = _e.reducerPath, context = _e.context, queryThunk = _e.queryThunk, mutationThunk = _e.mutationThunk;
      var isQueryThunk = (0, import_toolkit11.isAsyncThunkAction)(queryThunk);
      var isMutationThunk = (0, import_toolkit11.isAsyncThunkAction)(mutationThunk);
      var isFullfilledThunk = (0, import_toolkit11.isFulfilled)(queryThunk, mutationThunk);
      return function(mwApi) {
        var lifecycleMap = {};
        return function(next) {
          return function(action) {
            var stateBefore = mwApi.getState();
            var result = next(action);
            var cacheKey = getCacheKey(action);
            if (queryThunk.pending.match(action)) {
              var oldState = stateBefore[reducerPath].queries[cacheKey];
              var state = mwApi.getState()[reducerPath].queries[cacheKey];
              if (!oldState && state) {
                handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);
              }
            } else if (mutationThunk.pending.match(action)) {
              var state = mwApi.getState()[reducerPath].mutations[cacheKey];
              if (state) {
                handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);
              }
            } else if (isFullfilledThunk(action)) {
              var lifecycle = lifecycleMap[cacheKey];
              if (lifecycle == null ? void 0 : lifecycle.valueResolved) {
                lifecycle.valueResolved({
                  data: action.payload,
                  meta: action.meta.baseQueryMeta
                });
                delete lifecycle.valueResolved;
              }
            } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {
              var lifecycle = lifecycleMap[cacheKey];
              if (lifecycle) {
                delete lifecycleMap[cacheKey];
                lifecycle.cacheEntryRemoved();
              }
            } else if (api.util.resetApiState.match(action)) {
              for (var _i = 0, _e2 = Object.entries(lifecycleMap); _i < _e2.length; _i++) {
                var _f = _e2[_i], cacheKey2 = _f[0], lifecycle = _f[1];
                delete lifecycleMap[cacheKey2];
                lifecycle.cacheEntryRemoved();
              }
            }
            return result;
          };
        };
        function getCacheKey(action) {
          if (isQueryThunk(action))
            return action.meta.arg.queryCacheKey;
          if (isMutationThunk(action))
            return action.meta.requestId;
          if (api.internalActions.removeQueryResult.match(action))
            return action.payload.queryCacheKey;
          if (api.internalActions.removeMutationResult.match(action))
            return getMutationCacheKey(action.payload);
          return "";
        }
        function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi2, requestId) {
          var endpointDefinition = context.endpointDefinitions[endpointName];
          var onCacheEntryAdded = endpointDefinition == null ? void 0 : endpointDefinition.onCacheEntryAdded;
          if (!onCacheEntryAdded)
            return;
          var lifecycle = {};
          var cacheEntryRemoved = new Promise(function(resolve) {
            lifecycle.cacheEntryRemoved = resolve;
          });
          var cacheDataLoaded = Promise.race([
            new Promise(function(resolve) {
              lifecycle.valueResolved = resolve;
            }),
            cacheEntryRemoved.then(function() {
              throw neverResolvedError;
            })
          ]);
          cacheDataLoaded.catch(function() {
          });
          lifecycleMap[queryCacheKey] = lifecycle;
          var selector = api.endpoints[endpointName].select(endpointDefinition.type === DefinitionType.query ? originalArgs : queryCacheKey);
          var extra = mwApi2.dispatch(function(_, __, extra2) {
            return extra2;
          });
          var lifecycleApi = __spreadProps(__spreadValues({}, mwApi2), {
            getCacheEntry: function() {
              return selector(mwApi2.getState());
            },
            requestId,
            extra,
            updateCachedData: endpointDefinition.type === DefinitionType.query ? function(updateRecipe) {
              return mwApi2.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe));
            } : void 0,
            cacheDataLoaded,
            cacheEntryRemoved
          });
          var runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);
          Promise.resolve(runningHandler).catch(function(e) {
            if (e === neverResolvedError)
              return;
            throw e;
          });
        }
      };
    };
    var import_toolkit12 = __toModule((init_redux_toolkit_esm(), __toCommonJS(redux_toolkit_esm_exports)));
    var build6 = function(_e) {
      var api = _e.api, context = _e.context, queryThunk = _e.queryThunk, mutationThunk = _e.mutationThunk;
      var isPendingThunk = (0, import_toolkit12.isPending)(queryThunk, mutationThunk);
      var isRejectedThunk = (0, import_toolkit12.isRejected)(queryThunk, mutationThunk);
      var isFullfilledThunk = (0, import_toolkit12.isFulfilled)(queryThunk, mutationThunk);
      return function(mwApi) {
        var lifecycleMap = {};
        return function(next) {
          return function(action) {
            var _a, _b, _c;
            var result = next(action);
            if (isPendingThunk(action)) {
              var _e2 = action.meta, requestId = _e2.requestId, _f = _e2.arg, endpointName_1 = _f.endpointName, originalArgs_1 = _f.originalArgs;
              var endpointDefinition = context.endpointDefinitions[endpointName_1];
              var onQueryStarted = endpointDefinition == null ? void 0 : endpointDefinition.onQueryStarted;
              if (onQueryStarted) {
                var lifecycle_1 = {};
                var queryFulfilled = new Promise(function(resolve, reject) {
                  lifecycle_1.resolve = resolve;
                  lifecycle_1.reject = reject;
                });
                queryFulfilled.catch(function() {
                });
                lifecycleMap[requestId] = lifecycle_1;
                var selector_1 = api.endpoints[endpointName_1].select(endpointDefinition.type === DefinitionType.query ? originalArgs_1 : requestId);
                var extra = mwApi.dispatch(function(_, __, extra2) {
                  return extra2;
                });
                var lifecycleApi = __spreadProps(__spreadValues({}, mwApi), {
                  getCacheEntry: function() {
                    return selector_1(mwApi.getState());
                  },
                  requestId,
                  extra,
                  updateCachedData: endpointDefinition.type === DefinitionType.query ? function(updateRecipe) {
                    return mwApi.dispatch(api.util.updateQueryData(endpointName_1, originalArgs_1, updateRecipe));
                  } : void 0,
                  queryFulfilled
                });
                onQueryStarted(originalArgs_1, lifecycleApi);
              }
            } else if (isFullfilledThunk(action)) {
              var _g = action.meta, requestId = _g.requestId, baseQueryMeta = _g.baseQueryMeta;
              (_a = lifecycleMap[requestId]) == null ? void 0 : _a.resolve({
                data: action.payload,
                meta: baseQueryMeta
              });
              delete lifecycleMap[requestId];
            } else if (isRejectedThunk(action)) {
              var _h = action.meta, requestId = _h.requestId, rejectedWithValue = _h.rejectedWithValue, baseQueryMeta = _h.baseQueryMeta;
              (_c = lifecycleMap[requestId]) == null ? void 0 : _c.reject({
                error: (_b = action.payload) != null ? _b : action.error,
                isUnhandledError: !rejectedWithValue,
                meta: baseQueryMeta
              });
              delete lifecycleMap[requestId];
            }
            return result;
          };
        };
      };
    };
    var build7 = function(_e) {
      var api = _e.api, apiUid = _e.context.apiUid, reducerPath = _e.reducerPath;
      return function(mwApi) {
        var initialized2 = false;
        return function(next) {
          return function(action) {
            var _a, _b;
            if (!initialized2) {
              initialized2 = true;
              mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));
            }
            var result = next(action);
            if (api.util.resetApiState.match(action)) {
              mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));
            }
            if (typeof process !== "undefined" && true) {
              if (api.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && ((_b = (_a = mwApi.getState()[reducerPath]) == null ? void 0 : _a.config) == null ? void 0 : _b.middlewareRegistered) === "conflict") {
                console.warn('There is a mismatch between slice and middleware for the reducerPath "' + reducerPath + '".\nYou can only have one api per reducer path, this will lead to crashes in various situations!' + (reducerPath === "api" ? "\nIf you have multiple apis, you *have* to specify the reducerPath option when using createApi!" : ""));
              }
            }
            return result;
          };
        };
      };
    };
    function buildMiddleware(input) {
      var reducerPath = input.reducerPath, queryThunk = input.queryThunk;
      var actions = {
        invalidateTags: (0, import_toolkit13.createAction)(reducerPath + "/invalidateTags")
      };
      var middlewares = [
        build7,
        build,
        build2,
        build3,
        build4,
        build5,
        build6
      ].map(function(build8) {
        return build8(__spreadProps(__spreadValues({}, input), {
          refetchQuery
        }));
      });
      var middleware = function(mwApi) {
        return function(next) {
          var applied = (0, import_redux.compose).apply(void 0, middlewares.map(function(middleware2) {
            return middleware2(mwApi);
          }))(next);
          return function(action) {
            if (mwApi.getState()[reducerPath]) {
              return applied(action);
            }
            return next(action);
          };
        };
      };
      return { middleware, actions };
      function refetchQuery(querySubState, queryCacheKey, override) {
        if (override === void 0) {
          override = {};
        }
        return queryThunk(__spreadValues({
          type: "query",
          endpointName: querySubState.endpointName,
          originalArgs: querySubState.originalArgs,
          subscribe: false,
          forceRefetch: true,
          queryCacheKey
        }, override));
      }
    }
    function buildInitiate(_e) {
      var serializeQueryArgs = _e.serializeQueryArgs, queryThunk = _e.queryThunk, mutationThunk = _e.mutationThunk, api = _e.api, context = _e.context;
      var runningQueries = {};
      var runningMutations = {};
      var _f = api.internalActions, unsubscribeQueryResult = _f.unsubscribeQueryResult, removeMutationResult = _f.removeMutationResult, updateSubscriptionOptions = _f.updateSubscriptionOptions;
      return {
        buildInitiateQuery,
        buildInitiateMutation,
        getRunningOperationPromises,
        getRunningOperationPromise
      };
      function getRunningOperationPromise(endpointName, argOrRequestId) {
        var endpointDefinition = context.endpointDefinitions[endpointName];
        if (endpointDefinition.type === DefinitionType.query) {
          var queryCacheKey = serializeQueryArgs({
            queryArgs: argOrRequestId,
            endpointDefinition,
            endpointName
          });
          return runningQueries[queryCacheKey];
        } else {
          return runningMutations[argOrRequestId];
        }
      }
      function getRunningOperationPromises() {
        return __spreadArray(__spreadArray([], Object.values(runningQueries)), Object.values(runningMutations)).filter(function(t) {
          return !!t;
        });
      }
      function middlewareWarning(getState) {
        var _a, _b;
        if (true) {
          if (middlewareWarning.triggered)
            return;
          var registered = (_b = (_a = getState()[api.reducerPath]) == null ? void 0 : _a.config) == null ? void 0 : _b.middlewareRegistered;
          if (registered !== void 0) {
            ;
            middlewareWarning.triggered = true;
          }
          if (registered === false) {
            console.warn('Warning: Middleware for RTK-Query API at reducerPath "' + api.reducerPath + '" has not been added to the store.\nFeatures like automatic cache collection, automatic refetching etc. will not be available.');
          }
        }
      }
      function buildInitiateQuery(endpointName, endpointDefinition) {
        var queryAction = function(arg, _e2) {
          var _f2 = _e2 === void 0 ? {} : _e2, _g = _f2.subscribe, subscribe = _g === void 0 ? true : _g, forceRefetch = _f2.forceRefetch, subscriptionOptions = _f2.subscriptionOptions;
          return function(dispatch, getState) {
            var queryCacheKey = serializeQueryArgs({
              queryArgs: arg,
              endpointDefinition,
              endpointName
            });
            var thunk = queryThunk({
              type: "query",
              subscribe,
              forceRefetch,
              subscriptionOptions,
              endpointName,
              originalArgs: arg,
              queryCacheKey
            });
            var thunkResult = dispatch(thunk);
            middlewareWarning(getState);
            var requestId = thunkResult.requestId, abort = thunkResult.abort;
            var statePromise = Object.assign(Promise.all([runningQueries[queryCacheKey], thunkResult]).then(function() {
              return api.endpoints[endpointName].select(arg)(getState());
            }), {
              arg,
              requestId,
              subscriptionOptions,
              queryCacheKey,
              abort,
              unwrap: function() {
                return __async(this, null, function() {
                  var result;
                  return __generator(this, function(_e3) {
                    switch (_e3.label) {
                      case 0:
                        return [4, statePromise];
                      case 1:
                        result = _e3.sent();
                        if (result.isError) {
                          throw result.error;
                        }
                        return [2, result.data];
                    }
                  });
                });
              },
              refetch: function() {
                dispatch(queryAction(arg, { subscribe: false, forceRefetch: true }));
              },
              unsubscribe: function() {
                if (subscribe)
                  dispatch(unsubscribeQueryResult({
                    queryCacheKey,
                    requestId
                  }));
              },
              updateSubscriptionOptions: function(options) {
                statePromise.subscriptionOptions = options;
                dispatch(updateSubscriptionOptions({
                  endpointName,
                  requestId,
                  queryCacheKey,
                  options
                }));
              }
            });
            if (!runningQueries[queryCacheKey]) {
              runningQueries[queryCacheKey] = statePromise;
              statePromise.then(function() {
                delete runningQueries[queryCacheKey];
              });
            }
            return statePromise;
          };
        };
        return queryAction;
      }
      function buildInitiateMutation(endpointName) {
        return function(arg, _e2) {
          var _f2 = _e2 === void 0 ? {} : _e2, _g = _f2.track, track = _g === void 0 ? true : _g, fixedCacheKey = _f2.fixedCacheKey;
          return function(dispatch, getState) {
            var thunk = mutationThunk({
              type: "mutation",
              endpointName,
              originalArgs: arg,
              track,
              fixedCacheKey
            });
            var thunkResult = dispatch(thunk);
            middlewareWarning(getState);
            var requestId = thunkResult.requestId, abort = thunkResult.abort, unwrap = thunkResult.unwrap;
            var returnValuePromise = thunkResult.unwrap().then(function(data) {
              return { data };
            }).catch(function(error) {
              return { error };
            });
            var reset = function() {
              dispatch(removeMutationResult({ requestId, fixedCacheKey }));
            };
            var ret = Object.assign(returnValuePromise, {
              arg: thunkResult.arg,
              requestId,
              abort,
              unwrap,
              unsubscribe: reset,
              reset
            });
            runningMutations[requestId] = ret;
            ret.then(function() {
              delete runningMutations[requestId];
            });
            if (fixedCacheKey) {
              runningMutations[fixedCacheKey] = ret;
              ret.then(function() {
                if (runningMutations[fixedCacheKey] === ret)
                  delete runningMutations[fixedCacheKey];
              });
            }
            return ret;
          };
        };
      }
    }
    function assertCast(v) {
    }
    function safeAssign(target) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      Object.assign.apply(Object, __spreadArray([target], args));
    }
    var import_immer3 = __toModule(require_dist());
    var coreModuleName = Symbol();
    var coreModule = function() {
      return {
        name: coreModuleName,
        init: function(api, _e, context) {
          var baseQuery = _e.baseQuery, tagTypes = _e.tagTypes, reducerPath = _e.reducerPath, serializeQueryArgs = _e.serializeQueryArgs, keepUnusedDataFor = _e.keepUnusedDataFor, refetchOnMountOrArgChange = _e.refetchOnMountOrArgChange, refetchOnFocus = _e.refetchOnFocus, refetchOnReconnect = _e.refetchOnReconnect;
          (0, import_immer3.enablePatches)();
          assertCast(serializeQueryArgs);
          var assertTagType = function(tag) {
            if (typeof process !== "undefined" && true) {
              if (!tagTypes.includes(tag.type)) {
                console.error("Tag type '" + tag.type + "' was used, but not specified in `tagTypes`!");
              }
            }
            return tag;
          };
          Object.assign(api, {
            reducerPath,
            endpoints: {},
            internalActions: {
              onOnline,
              onOffline,
              onFocus,
              onFocusLost
            },
            util: {}
          });
          var _f = buildThunks({
            baseQuery,
            reducerPath,
            context,
            api,
            serializeQueryArgs
          }), queryThunk = _f.queryThunk, mutationThunk = _f.mutationThunk, patchQueryData = _f.patchQueryData, updateQueryData = _f.updateQueryData, prefetch = _f.prefetch, buildMatchThunkActions = _f.buildMatchThunkActions;
          var _g = buildSlice({
            context,
            queryThunk,
            mutationThunk,
            reducerPath,
            assertTagType,
            config: {
              refetchOnFocus,
              refetchOnReconnect,
              refetchOnMountOrArgChange,
              keepUnusedDataFor,
              reducerPath
            }
          }), reducer = _g.reducer, sliceActions = _g.actions;
          safeAssign(api.util, {
            patchQueryData,
            updateQueryData,
            prefetch,
            resetApiState: sliceActions.resetApiState
          });
          safeAssign(api.internalActions, sliceActions);
          Object.defineProperty(api.util, "updateQueryResult", {
            get: function() {
              if (typeof process !== "undefined" && true) {
                console.warn("`api.util.updateQueryResult` has been renamed to `api.util.updateQueryData`, please change your code accordingly");
              }
              return api.util.updateQueryData;
            }
          });
          Object.defineProperty(api.util, "patchQueryResult", {
            get: function() {
              if (typeof process !== "undefined" && true) {
                console.warn("`api.util.patchQueryResult` has been renamed to `api.util.patchQueryData`, please change your code accordingly");
              }
              return api.util.patchQueryData;
            }
          });
          var _h = buildMiddleware({
            reducerPath,
            context,
            queryThunk,
            mutationThunk,
            api,
            assertTagType
          }), middleware = _h.middleware, middlewareActions = _h.actions;
          safeAssign(api.util, middlewareActions);
          safeAssign(api, { reducer, middleware });
          var _j = buildSelectors({
            serializeQueryArgs,
            reducerPath
          }), buildQuerySelector = _j.buildQuerySelector, buildMutationSelector = _j.buildMutationSelector, selectInvalidatedBy = _j.selectInvalidatedBy;
          safeAssign(api.util, { selectInvalidatedBy });
          var _k = buildInitiate({
            queryThunk,
            mutationThunk,
            api,
            serializeQueryArgs,
            context
          }), buildInitiateQuery = _k.buildInitiateQuery, buildInitiateMutation = _k.buildInitiateMutation, getRunningOperationPromises = _k.getRunningOperationPromises, getRunningOperationPromise = _k.getRunningOperationPromise;
          safeAssign(api.util, {
            getRunningOperationPromises,
            getRunningOperationPromise
          });
          return {
            name: coreModuleName,
            injectEndpoint: function(endpointName, definition) {
              var _a, _b;
              var anyApi = api;
              (_b = (_a = anyApi.endpoints)[endpointName]) != null ? _b : _a[endpointName] = {};
              if (isQueryDefinition(definition)) {
                safeAssign(anyApi.endpoints[endpointName], {
                  select: buildQuerySelector(endpointName, definition),
                  initiate: buildInitiateQuery(endpointName, definition)
                }, buildMatchThunkActions(queryThunk, endpointName));
              } else if (isMutationDefinition(definition)) {
                safeAssign(anyApi.endpoints[endpointName], {
                  select: buildMutationSelector(),
                  initiate: buildInitiateMutation(endpointName)
                }, buildMatchThunkActions(mutationThunk, endpointName));
              }
            }
          };
        }
      };
    };
    var createApi = buildCreateApi(coreModule());
  }
});

// node_modules/@reduxjs/toolkit/dist/query/index.js
var require_query = __commonJS({
  "node_modules/@reduxjs/toolkit/dist/query/index.js"(exports, module) {
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_rtk_query_cjs_development();
    }
  }
});
export default require_query();
//# sourceMappingURL=@reduxjs_toolkit_dist_query.js.map
